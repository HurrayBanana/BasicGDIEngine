using System;
using System.Text;
using System.Collections.Generic;
using System.Linq;
//using Microsoft.Xna.Framework;
//using Microsoft.Xna.Framework.Audio;
//using Microsoft.Xna.Framework.Content;
//using Microsoft.Xna.Framework.GamerServices;
//using Microsoft.Xna.Framework.Graphics;
//using Microsoft.Xna.Framework.Input;
//using Microsoft.Xna.Framework.Media;
//extras
using System.Drawing;
using System.Drawing.Drawing2D;

using System.IO;
using System.IO.IsolatedStorage;


namespace GDITest
{
    //TODO NEED TO INTEGRATE THE TILE MAP CODE I CREATED PARTICULARY THE HELPER STUFF
    //SHOULD HOLD A CENTRAL LIST OF TILES in one big list and have this managed by the TileMapManager
    //so tile maps can be easily created and generated
    /// <summary>
    /// Specifies the type and structure of a particular tilemap layer
    /// </summary>
    public class TileMap : IUpdatable
    {
        ///// <summary>
        ///// a method called as each tile is decoded on load. If null then it is ignored
        ///// </summary>
        //public TileCallBack TileLoadCallBack;
        /// <summary>
        /// a default size to use for tile width and height
        /// works well with 800x600 and 1280x720
        /// </summary>
        private const int defaultTileSize = 40;
        /// <summary>
        /// number representing left direction in tilemap
        /// </summary>
        public const int LEFT = 0;
        /// <summary>
        /// number representing right direction in tilemap
        /// </summary>
        public const int RIGHT = 1;
        /// <summary>
        /// number representing up direction in tilemap
        /// </summary>
        public const int UP = 2;
        /// <summary>
        /// number representing down direction in tilemap
        /// </summary>
        public const int DOWN = 3;
        /// <summary>
        /// number representing NW direction in tilemap
        /// </summary>
        public const int UP_LEFT = 4;
        /// <summary>
        /// number representing NE direction in tilemap
        /// </summary>
        public const int UP_RIGHT = 5;
        /// <summary>
        /// number representing SE direction in tilemap
        /// </summary>
        public const int DOWN_LEFT = 6;
        /// <summary>
        /// number representing SE direction in tilemap
        /// </summary>
        public const int DOWN_RIGHT = 7;

        /// <summary>
        /// no direction or not moving
        /// </summary>
        public const int NONE = -1;
        /// <summary>
        /// empty tile (no tile exists at this location)
        /// </summary>
        public const int EMPTY = -1;
        /// <summary>
        /// the unique tiles that this sheet uses (calculated if generated automatically)
        /// or overwritten if generated by the user
        /// </summary>
        internal Tile[] myTileList;
        /// <summary>
        /// holds the number of unique tiles used by this tilemap
        /// </summary>
        internal int tileCount = 0;
        /// <summary>
        /// gets or sets the array of Tiles that are used to draw this tilemap
        /// You only need to set this if you are dynamically creating your own Tilemaps
        /// If you are just tiling a texture (graphic) you should not alter this
        /// </summary>
        public Tile[] MyTileList
        {
            get { return myTileList; }
            set {
                myTileList = value;
                tileCount = value.Length;
            }
        }

        /// <summary>
        /// the tile indexes for drawing this tilemap
        /// empty tiles recorded with a -1 index
        /// this is row major (row specified as first index then column)
        /// </summary>
        internal int[,] dTiles;
        /// <summary>
        /// gets the tile map used to draw this map
        /// row major, first index is the row of the tile, second index is the column of the tile
        /// </summary>
        public int[,] Map
        {
            get { return dTiles; }
            set { dTiles = value; }
        }
        /// <summary>
        /// takes a route of tile locations and converts into vector3 co-ordinates fro a track based sprite for instance
        /// </summary>
        /// <param name="route">The route of tile locations to follow</param>
        /// <returns>A list of vector 3 locations</returns>
        public List<Vector3> RouteToVector3(List<Point> route)
        {
            List<Vector3> path = new List<Vector3>();
            foreach (Point location in route)
            {
                path.Add(new Vector3(PixelLocationCentre(location),0));
            }
            return path;
        }
        /// <summary>
        /// takes a route of tile locations and converts into vector2 co-ordinates for your own path following
        /// </summary>
        /// <param name="route">The route of tile locations to follow</param>
        /// <returns>A list of vector 2 locations</returns>
        public List<Vector2> RouteToVector2(List<Point> route)
        {
            List<Vector2> path = new List<Vector2>();
            foreach (Point location in route)
            {
                path.Add(PixelLocationCentre(location));
            }
            return path;
        }
        /// <summary>
        /// takes a route of tile locations and converts into vector3 co-ordinates fro a track based sprite for instance
        /// </summary>
        /// <param name="route">The route of tile locations to follow</param>
        /// <param name="prePend">A position to start the route from (use the sprites current position so you don't jump to the centre of current tile)</param>
        /// <returns>A list of vector 3 locations</returns>
        public List<Vector3> RouteToVector3(Vector3 prePend, List<Point> route)
        {
            List<Vector3> path = RouteToVector3(route);
            
            path.Insert(0, prePend);
            return path;
        }
        /// <summary>
        /// takes a route of tile locations and converts into vector2 co-ordinates for your own path following
        /// </summary>
        /// <param name="route">The route of tile locations to follow</param>
        /// <param name="prePend">A position to start the route from (use the sprites current position so you don't jump to the centre of current tile)</param>
        /// <returns>A list of vector 2 locations</returns>
        public List<Vector2> RouteToVector2(Vector2 prePend, List<Point> route)
        {
            List<Vector2> path = RouteToVector2(route);
            path.Insert(0, prePend);

            return path;
        }
        /// <summary>
        /// creates a vector3 direction vector from a tile direction
        /// </summary>
        /// <param name="tileDirection"></param>
        /// <returns>unit direction vector3, zero if no ordinal direction</returns>
        public static Vector3 TileDirectionTo3D(int tileDirection)
        {
            switch (tileDirection)
            {
                case LEFT: return new Vector3(-1, 0, 0);
                case RIGHT: return new Vector3(1, 0, 0);
                case UP: return new Vector3(0, -1, 0);
                case DOWN: return new Vector3(0, 1, 0);
                case UP_LEFT: return new Vector3(-1, -1, 0);
                case UP_RIGHT: return new Vector3(1, -1, 0);
                case DOWN_LEFT: return new Vector3(-1, 1, 0);
                case DOWN_RIGHT: return new Vector3(1, 1, 0);
            }
            return Vector3.Zero;
        }
        /// <summary>
        /// creates a vector2 direction vector from a tile direction
        /// </summary>
        /// <param name="tileDirection"></param>
        /// <returns>unit direction vector2, zero if no ordinal direction</returns>
        public static Vector2 TileDirectionTo2D(int tileDirection)
        {
            switch (tileDirection)
            {
                case LEFT: return new Vector2(-1, 0);
                case RIGHT: return new Vector2(1, 0);
                case UP: return new Vector2(0, -1);
                case DOWN: return new Vector2(0, 1);
            }
            return Vector2.Zero;
        }
        /// <summary>
        /// sets a tile value at a given location
        /// </summary>
        /// <param name="location">The tile position, x is the column, y is the row</param>
        /// <param name="tile">the tile number to place here, -1 clears a tile</param>
        /// <code>
        /// //this code picks a tile location based on a sprites position and uses
        /// //this to set a tile value at that location
        /// 
        /// Point tile = GFX.tmTheGrid.TileLocation(cycle.Centre.X, cycle.Bottom + 1);
        /// GFX.tmTheGrid.SetTile(tile, tileNumber);
        /// </code>
        public void SetGraphic(Point location, int tile)
        {
            //only set tile locations that exist
            if (ValidTile(location))
               dTiles[location.Y, location.X] = tile;
        }
        /// <summary>
        /// sets a collision tile to a particular value
        /// </summary>
        /// <param name="location">The tile position, x is the column, y is the row</param>
        /// <param name="tile">the collision tile number to place here</param>
        public void SetCollision(Point location, int tile)
        {
            if (ValidTile(location))
            cTiles[location.Y, location.X] = tile;
        }
        /// <summary>
        /// overridable called when a TileMap is removed
        /// add code to remove/kill any other resources managed by the TileMap (helper/friend sprites, events etc...)
        /// if you don't they could still be active
        /// </summary>
        public virtual void CleanUp()
        {

        }
        /// <summary>
        /// gets the tile for a particular tile number
        /// </summary>
        /// <param name="tileNumber"></param>
        /// <returns></returns>
        public Tile Info(int tileNumber)
        {
            if (tileNumber < myTileList.Length && tileNumber >= 0)
            {
                return myTileList[tileNumber];
            }
            return null;
        }
        /// <summary>
        /// gets the contents of a tile from the given tile location
        /// </summary>
        /// <param name="location">The tile position, x is the column, y is the row</param>
        /// <returns>contents of the tile or -1 if the tile is not within the tilemap</returns>
        public int GetGraphic(Point location)
        {
            if (WrapTileInterrogation)
            {
                if (location.X < 0) location.X += Columns;
                else if (location.X > Columns - 1) location.X -= Columns;
                if (location.Y < 0) location.Y += Rows;
                else if (location.Y > Rows - 1) location.Y -= Rows;
            }

            if (ValidTile(location))
                return dTiles[location.Y, location.X];
            else
                return -1;
        }
        /// <summary>
        /// gets the contents of a tile from the given tile location and direction
        /// </summary>
        /// <param name="location">tile location to retrieve</param>
        /// <param name="direction">TileMap.Left, TileMap.Right, TileMap.Right, TileMap.Down</param>
        /// <param name="distance">tile offset</param>
        /// <returns>tile id or -1 if no tile exists or location is not valid</returns>
        public int GetGraphic(Point location, int direction, int distance)
        {
            switch (direction)
            {
                case LEFT: GetGraphic(new Point(location.X - distance, location.Y)); break;
                case RIGHT: GetGraphic(new Point(location.X + distance, location.Y)); break;
                case UP: GetGraphic(new Point(location.X, location.Y - distance)); break;
                case DOWN: GetGraphic(new Point(location.X, location.Y + distance)); break;
                case UP_LEFT: GetGraphic(new Point(location.X - distance, location.Y - distance)); break;
                case UP_RIGHT : GetGraphic(new Point(location.X + distance, location.Y - distance)); break;
                case DOWN_LEFT: GetGraphic(new Point(location.X - distance, location.Y + distance)); break;
                case DOWN_RIGHT: GetGraphic(new Point(location.X + distance, location.Y + distance)); break;
                default: GetGraphic(new Point(location.X, location.Y)); break;
            }
            return -1; 
        }
        /// <summary>
        /// gets the contents of a collision tile from the given tile location
        /// </summary>
        /// <param name="location">The tile position, x is the column, y is the row</param>
        /// <returns>contents of the tile or -1 if the tile is not within the tilemap</returns>
        public int GetCollision(Point location)
        {
            if (WrapTileInterrogation)
            {
                if (location.X < 0) location.X += Columns;
                else if (location.X > Columns - 1) location.X -= Columns;
                if (location.Y < 0) location.Y += Rows;
                else if (location.Y > Rows - 1) location.Y -= Rows;
            }

            if (ValidTile(location))
                return cTiles[location.Y, location.X];
            else
                return -1;
        }
        /// <summary>
        /// gets the contents of a collision tile from the given tile location and direction
        /// </summary>
        /// <param name="location">tile location to retrieve</param>
        /// <param name="direction">TileMap.Left, TileMap.Right, TileMap.Right, TileMap.Down</param>
        /// <param name="distance">tile offset</param>
        /// <returns>tile id or -1 if no tile exists or location is not valid</returns>
        public int GetCollision(Point location, int direction, int distance)
        {
            switch (direction)
            {
                case LEFT: GetCollision(new Point(location.X - distance, location.Y)); break;
                case RIGHT: GetCollision(new Point(location.X + distance, location.Y)); break;
                case UP: GetCollision(new Point(location.X, location.Y - distance)); break;
                case DOWN: GetCollision(new Point(location.X, location.Y + distance)); break;
                case UP_LEFT: GetCollision(new Point(location.X - distance, location.Y - distance)); break;
                case UP_RIGHT: GetCollision(new Point(location.X + distance, location.Y - distance)); break;
                case DOWN_LEFT: GetCollision(new Point(location.X - distance, location.Y + distance)); break;
                case DOWN_RIGHT: GetCollision(new Point(location.X + distance, location.Y + distance)); break;
                default: GetCollision(new Point(location.X, location.Y)); break;
            }
            return -1;
        }


        /// <summary>
        /// uses a string map file that contains the information on map size and tile map values
        /// size is determined automatically by the width of data and number of lines in map.
        /// 
        /// first string is a string containing the tile positions for the characters.
        /// eg if the first string contained "abcd" this would convert
        /// subsequent tile values from a to 0, b to 1, c to 2, and d to tile 3
        /// any other character turned into a null tile -1
        /// 
        /// second string in file contains the width and height of the tiles in tilemap
        /// 
        /// example file start - lines starting with ; are ignored
        /// 
        /// ;a - is border
        /// ;b - is a breakable wall character
        /// ;c - is player start position
        /// ;x - ignored so empty tile is placed at this location
        /// abcdefg
        /// ;tile width 16 and 20 high
        /// 16,20
        /// aaaaaaa
        /// axxbxxa
        /// axxcxxa
        /// axxbxxa
        /// aaaaaaa
        /// 
        /// would create a tile map 5 rows and 7 columns, tile size 16 pixles wide and 20 pixels high with 7 different tiles
        /// a border of tile 0 with tile 1 in a line down the centre, null tiles everywhere else
        ///
        /// </summary>
        /// <param name="filename">filename containing the map</param>
        /// <returns>true if read correctly</returns>
        /// <remarks></remarks>
        public bool LoadMapFromStringFile(string filename)
        {
            //scan file first into a list of strings to count width and height
            List<string> mapdata = new List<string>();

            Stream stream = null;
            try
            {
                stream = TitleContainer.OpenStream(filename);
            //using (var stream = TitleContainer.OpenStream(filename))
            //{
                using (StreamReader sr = new StreamReader(stream))
                {
                    stream = null;
                    String line;
                    while ((line = sr.ReadLine()) != null)
                    {
                        //ignore comment lines
                        if (line.Length > 0 && line[0] != ';')
                            mapdata.Add(line);
                    }
                }
            }
            finally
            {
                if(stream != null)
                    stream.Dispose();
            }
            //first line of file is the tile index data used to convert ascii into tilemap numbers
            tileIndex = mapdata[0];
            mapdata.RemoveAt(0);

            //get tile dimensions
            string[] dims = mapdata[0].Split(',');
            int tileWidth = Convert.ToInt32(dims[0]);
            int tileHeight = Convert.ToInt32(dims[1]);
            mapdata.RemoveAt(0);

            //get widest row
            int width = 0;
            foreach (string row in mapdata)
            {
                width = (row.Length > width) ? row.Length : width;
            }

            //create a map to dimensions given by scanning data
            int[,] map = new int[mapdata.Count, width];

            //scan string rows to build map based on tileindex given
            int c, r;
            r = 0;
            foreach (string row in mapdata)
            {
                c = 0;
                foreach (char tile in row)
                {
                    //int ti = tileIndex.IndexOf(tile);
                    //if (TileLoadCallBack != null)
                    //    ti = TileLoadCallBack(ti, new Point(c, r));
                    map[r, c++] = tileIndex.IndexOf(tile);// ti;
                }
                r++;
            }

            return SetMap(tileWidth, tileHeight, map);

        }

        /// <summary>
        /// uses a ascii comma separated map file that contains the information on map size and tile map values
        /// size is determined automatically by the width of data and number of lines in map.
        /// 
        /// first string is a string containing the tile positions for the characters.
        /// eg if the first string contained "abcd" this would convert
        /// subsequent tile values from a to 0, b to 1, c to 2, and d to tile 3
        /// any other character turned into a null tile -1
        /// 
        /// second string in file contains the width and height of the tiles in tilemap
        /// 
        /// exmaple file start, using space as a delimeter
        /// 
        /// abcdefg
        /// 16,20
        /// a a a a a a a
        /// a x x b x x a
        /// a x x b x x a
        /// a x x b x x a
        /// a a a a a a a
        /// 
        /// would create a tile map 5 rows and 7 columns, tile size 16 pixles wide and 20 pixels high with 7 different tiles
        /// a border of tile 0 with tile 1 in a line down the centre, null tiles everywhere else
        ///
        /// </summary>
        /// <param name="filename">filename containing the map</param>
        /// <param name="delimeter">The character that separates each tile reference in the map</param>
        /// <returns>true if read correctly</returns>
        /// <remarks></remarks>
        public bool LoadMapFromDelimetedFile(string filename, char delimeter)
        {
            //scan file first into a list of strings to count width and height
            List<string> mapdata = new List<string>();

            Stream stream = null;
            try
            {
                stream = TitleContainer.OpenStream(filename);
                //using (var stream = TitleContainer.OpenStream(filename))
                //{
                using (StreamReader sr = new StreamReader(stream))
                {
                    stream = null;
                    String line;
                    while ((line = sr.ReadLine()) != null)
                    {
                        mapdata.Add(line);
                    }
                }
            }
            finally
            {
                if (stream != null)
                    stream.Dispose();
            }

            //first line of file is the tile index data used to convert ascii into tilemap numbers
            tileIndex = mapdata[0];
            mapdata.RemoveAt(0);

            //get tile dimensions
            string[] dims = mapdata[0].Split(',');
            int tileWidth = Convert.ToInt32(dims[0]);
            int tileHeight = Convert.ToInt32(dims[1]);
            mapdata.RemoveAt(0);

            int width = 0;
            int i = 0;
            foreach (string row in mapdata)
            {
                i = row.Split(delimeter).Length;
                width = (i > width) ? i : width;
            }

            //create a map to dimensions given by scanning data
            int[,] map = new int[mapdata.Count, width];

            //scan csv rows to build map based on tileindex given
            int c, r;
            r = 0;
            foreach (string row in mapdata)
            {
                c = 0;
                foreach (string tile in row.Split(delimeter))
                {
                    //int ti = tileIndex.IndexOf(tile);
                    //if (TileLoadCallBack != null)
                    //    ti = TileLoadCallBack(ti, new Point(c, r));

                    map[r, c++] = tileIndex.IndexOf(tile); //ti;
                }
                r++;
            }

            return SetMap(tileWidth, tileHeight, map);
        }

        /// <summary>
        /// uses a ascii comma separated map file that contains the information on map size and tile map values
        /// size is determined automatically by the width of data and number of lines in map.
        /// 
        /// first string is a string containing the tile positions for the characters.
        /// eg if the first string contained "abcd" this would convert
        /// subsequent tile values from a to 0, b to 1, c to 2, and d to tile 3
        /// any other character turned into a null tile -1
        /// 
        /// second string in file contains the width and height of the tiles in tilemap
        /// 
        /// exmaple file start
        /// 
        /// abcdefg
        /// 16,20
        /// a,a,a,a,a,a,a
        /// a,x,x,b,x,x,a
        /// a,x,x,b,x,x,a
        /// a,x,x,b,x,x,a
        /// a,a,a,a,a,a,a
        /// 
        /// would create a tile map 5 rows and 7 columns, tile size 16 pixles wide and 20 pixels high with 7 different tiles
        /// a border of tile 0 with tile 1 in a line down the centre, null tiles everywhere else
        ///
        /// </summary>
        /// <param name="filename">filename containing the map</param>
        /// <returns>true if read correctly</returns>
        /// <remarks></remarks>
        public bool LoadMapFromCSVFile(string filename)
        {
            return LoadMapFromDelimetedFile(filename, ',');
        }
        /// <summary>
        /// Easily creates the correct sized sampling map based on area chosen and resolution. If you want per pixel sampling for collision set the tile size to 1,1
        /// </summary>
        /// <param name="horizontalResolution">resolution of map width must be a factor of map size e.g. if 1000 then 1, 5, 10 etc.. if 1024 needs to be 1, 2, 4, 8 etc...</param>
        /// <param name="verticalResolution">resolution of map height must be a factor of map size e.g. if 1000 then 1, 5, 10 etc.. if 1024 needs to be 1, 2, 4, 8 etc...</param>
        /// <param name="Area">The area the map needs to cover (should be same as level size)</param>
        /// <returns>true if the map was successfully created</returns>
        public bool SetSamplingMap(int horizontalResolution, int verticalResolution, Rectangle Area)
        {
            return SetSamplingMap(horizontalResolution, verticalResolution, Area.Width, Area.Height);
        }
        /// <summary>
        /// Easily creates the correct sized sampling map based on area chosen and resolution. If you want per pixel sampling for collision set the tile size to 1,1
        /// </summary>
        /// <param name="horizontalResolution">resolution of map width must be a factor of map size e.g. if 1000 then 1, 5, 10 etc.. if 1024 needs to be 1, 2, 4, 8 etc...</param>
        /// <param name="verticalResolution">resolution of map height must be a factor of map size e.g. if 1000 then 1, 5, 10 etc.. if 1024 needs to be 1, 2, 4, 8 etc...</param>
        /// <param name="tex">The texture whose dimensions specifies the area the map needs to cover (should be same as level size)</param>
        /// <returns>true if the map was successfully created</returns>
        public bool SetSamplingMap(int horizontalResolution, int verticalResolution, Image /*Texture2D*/ tex)
        {
            return SetSamplingMap(horizontalResolution, verticalResolution, tex.Width, tex.Height);
        }
        /// <summary>
        /// Easily creates the correct sized sampling map based on area chosen and resolution. If you want per pixel sampling for collision set the tile size to 1,1
        /// </summary>
        /// <param name="horizontalResolution">resolution of map width must be a factor of map size e.g. if 1000 then 1, 5, 10 etc.. if 1024 needs to be 1, 2, 4, 8 etc...</param>
        /// <param name="verticalResolution">resolution of map height must be a factor of map size e.g. if 1000 then 1, 5, 10 etc.. if 1024 needs to be 1, 2, 4, 8 etc...</param>
        /// <param name="width">The width of the area the map needs to cover (should be same as level size)</param>
        /// <param name="height">The height of the area the map needs to cover (should be same as level size)</param>
        /// <returns>true if the map was successfully created</returns>
        public bool SetSamplingMap(int horizontalResolution, int verticalResolution, int width, int height)
        {
            //make sure resolution is a factor of map area
            while (width % horizontalResolution != 0) horizontalResolution--;

            while (height % verticalResolution != 0) verticalResolution--;

            bool success = SetMap(horizontalResolution, verticalResolution, new int[height / verticalResolution, width / horizontalResolution]);
            if (horizontalResolution > 1)
                RenderProperties.Displacement.X = horizontalResolution / 2;
            if (verticalResolution > 1)
                RenderProperties.Displacement.Y = verticalResolution / 2;
            return success;
        }

        /// <summary>
        /// Manually sets the tilemap, if you want an empty tile (no content than place -1)
        /// Tile maps are a 2d array of integers referring to your tilelist.
        /// row major, first index is the row of the tiel, second index is the column of the tile
        /// It is your responsibility to ensure the tileList contains entries for tiles in your tilemap
        /// </summary>
        /// <param name="map">The 2d array of integers comprising the map</param>
        /// <param name="tileWidth">width of a tile</param>
        /// <param name="tileHeight">height of a tile</param>
        /// <returns>true if map given meets current Map definition, false if different from current spec
        /// If false new settings are made for map metrics</returns>
        public bool SetMap(int tileWidth, int tileHeight, int[,] map)
        {
            bool success = false;
            this.dTiles = map;
            //this is crap doesn't do anything ever why was it here?
            //if ((map.GetUpperBound(1) + 1) == this.Columns &&
            //    (map.GetUpperBound(0) + 1) == this.Rows)
            //{
            //    success = true;
            //}
            //set the columns and rows fields
            this.Columns = map.GetUpperBound(1) + 1;
            this.Rows = map.GetUpperBound(0) + 1;
            //calculate pixel dimensions
            this.Height = this.Rows * tileHeight;
            this.Width = this.Columns * tileWidth;
            //store tile size
            this.tileWidth = tileWidth;
            this.tileHeight = tileHeight;
            //create in case size changed
            CreateAlphaMap();
            CreateColorMap();
            //if (/*success && */TileLoadCallBack != null)
            //    ProcessMap();
            return success;
        }
        /// <summary>
        /// traverses the map and sends the call back the tile and location being processed
        /// </summary>
        /// <param name="tileProcessor">The method to call with tile data</param>
        public void ProcessGraphicMap(TileCallBack tileProcessor)
        {
            Point p = new Point(0, 0);
            for (int row = 0; row < RowCount; row++)
            {
                for (int col = 0; col < ColumnCount; col++)
                {
                    p.X = col;
                    p.Y = row;
                    //ignore empty tiles
                    if (Map[row,col] != -1)
                        Map[row, col] = tileProcessor(Map[row, col], p);
                }
            }
        }

        /// <summary>
        /// Manually sets the tilemap making a copy of the original so any dynamic changes
        /// will not affect the original map, if you want an empty tile (no content than place -1)
        /// Tile maps are a 2d array of integers referring to your tilelist.
        /// row major, first index is the row of the tiel, second index is the column of the tile
        /// It is your responsibility to ensure the tileList contains entries for tiles in your tilemap
        /// </summary>
        /// <param name="map">The 2d array of integers comprising the map which we want to copy without destroying</param>
        /// <param name="tileWidth">width of a tile</param>
        /// <param name="tileHeight">height of a tile</param>
        /// <returns>true if map given meets current Map definition, false if different from current spec
        /// If false new settings are made for map metrics</returns>
        public bool SetMapCopy(int tileWidth, int tileHeight, int[,] map)
        {
            int[,] newMap = new int[map.GetUpperBound(0) + 1, map.GetUpperBound(1) + 1];
            for (int r = 0; r < map.GetUpperBound(0) + 1; r++)
            {
                for (int c = 0; c < map.GetUpperBound(1) + 1; c++)
                    newMap[r, c] = map[r, c];
            }
            return SetMap(tileWidth, tileHeight, newMap);
        }

        /// <summary>
        /// Attempts to take a tilemap.
        /// Use this to setup a mini map from an existing tilemap
        /// you will need to manually setup you tiles in your minimap constructor 
        /// as well as clone any alpha and colour maps using CopyColorMap and CopyAlphaMap if you need those
        /// </summary>
        /// <param name="cloneThis">The tilemap to take the definitions from</param>
        public void SetMapCloneFrom(TileMap cloneThis)
        {
            //take a copy of map
            SetMapCopy(cloneThis.tileWidth, cloneThis.tileHeight, cloneThis.Map);
        }

        /// <summary>
        /// takes a copy of an exisiting colour map
        /// </summary>
        /// <returns>copy of color map</returns>
        public Color[,] CopyColorMap()
        {
            Color[,] newMap = new Color[Rows, Columns];
            for (int r = 0; r < Rows; r++)
            {
                for (int c = 0; c < Columns; c++)
                    newMap[r, c] = colorMap[r, c];
            }
            return newMap;
        }

        /// <summary>
        /// returns a copy of an existing colour map
        /// </summary>
        /// <returns>copy of alpha map</returns>
        public float[,] CopyAlphaMap()
        {
            float[,] newMap = new float[Rows, Columns];
            for (int r = 0; r < Rows; r++)
            {
                for (int c = 0; c < Columns; c++)
                    newMap[r, c] = alphaMap[r, c];
            }
            return newMap;
        }

        /// <summary>
        /// gets a copy of the current TileMap
        /// </summary>
        /// <returns>a copy of the map for storage purposes</returns>
        public int[,] CopyMap()
        {
            int[,] newMap = new int[Rows, Columns];
            for (int r = 0; r < Rows; r++)
            {
                for (int c = 0; c < Columns; c++)
                    newMap[r, c] = dTiles[r, c];
            }
            return newMap;
        }
        /// <summary>
        /// Collision tile indexes (same dimensions as the tile map) can refer to any numbers you want
        /// By default filled with 0
        /// </summary>
        internal int[,] cTiles;
        /// <summary>
        /// gets or sets the Collision tile indexes (same dimensions as the tile map)
        /// can refer to any numbers you want
        /// </summary>
        public int[,] CollisionMap { get { return cTiles; } set { cTiles = value; } }
        // - update stuff
        /// <summary>
        /// the number of pixels (x,y) that we wish to scroll the tilemap per second
        /// </summary>
        internal Vector2 _scroll = Vector2.Zero;
        /// <summary>
        /// the number of pixels (x,y) that we wish to scroll the tilemap per second
        /// </summary>
        public Vector2 Scroll
        {
            get { return _scroll; }
            set {
                _scroll = value;
                _scrollAmount.X = _scroll.X * _scrollMultiplier;
                _scrollAmount.Y = _scroll.Y * _scrollMultiplier;
            }
        }
        /// <summary>
        /// gets or sets the X component of the scrolling for the tilemap
        /// </summary>
        public float ScrollX
        {
            get { return _scroll.X; }
            set
            {
                _scroll.X = value;
                _scrollAmount.X = _scroll.X * _scrollMultiplier;
            }
        }
        /// <summary>
        /// gets or sets the Y component of the scrolling for the tilemap
        /// </summary>
        public float ScrollY
        {
            get { return _scroll.Y; }
            set
            {
                _scroll.Y = value;
                _scrollAmount.Y = _scroll.Y * _scrollMultiplier;
            }
        }
        /// <summary>
        /// the a factor to multiply the scrolling by to make it easier to achieve parallax effects
        /// default is 1
        /// </summary>
        private float _scrollMultiplier = 1;
        /// <summary>
        /// the a factor to multiply the scrolling by to make it easier to achieve parallax effects
        /// default is 1
        /// </summary>
        public float ScrollMultiplier
        {
            get { return _scrollMultiplier; }
            set { 
                _scrollMultiplier = value;
                _scrollAmount.X = _scroll.X * _scrollMultiplier;
                _scrollAmount.Y = _scroll.Y * _scrollMultiplier;
            }
        }
        /// <summary>
        /// holds pre-calculated scroll and scrollMultiplier
        /// </summary>
        internal Vector2 _scrollAmount;
        /// <summary>
        /// color wash to apply to the entire tilemap if GlobalWash is set to true.
        /// Which by default is turned off to allow per tile washes instead
        /// </summary>
        public Color Wash = Color.White;
        /// <summary>
        /// internal alpha
        /// </summary>
        private float _alpha = 1;
        /// <summary>
        /// the transparency of the tilemap
        /// </summary>
        public float Alpha
        {
            get { return _alpha; }
            set { _alpha = MathHelper.Clamp(value,0, 1); }
        }
        /// <summary>
        ///  if true the new AlphaMap is used to determine the transparency of each tile rendered. if false the global Alpha value will be used to render tiles
        /// </summary>
        public bool UseAlphaMap = false;
        /// <summary>
        /// A 2d array that holds an alpha value (a float between 0 and 1)  for individual tiles, this could be used to create fade effects across tilemaps. Only active when UseAlphaMap is set to true, otherwise global Alpha is applied to a tile when rendered.
        /// The AlphaMap will be created when the tilemap is Constructed populated with full alpha (1.0f)
        /// </summary>
        private float[,] alphaMap;
        /// <summary>
        /// gets or sets a 2d array that holds an alpha value (a float between 0 and 1)  for individual tiles, this could be used to create fade effects across tilemaps. Only active when UseAlphaMap is set to true, otherwise global Alpha is applied to a tile when rendered
        /// </summary>
        public float[,] AlphaMap
        {
            get { return alphaMap; }
            set { alphaMap = value; }
        }
        /// <summary>
        /// holds the colour map for the tilemap
        /// </summary>
        private Color[,] colorMap;
        /// <summary>
        /// gets or sets a 2d array that holds a Color wash value for individual tiles, 
        /// this could be used to black out fade effects across tilemaps. 
        /// Only active when UseWashMap is set to true, otherwise global or per tile Washing is applied to a tile when rendered
        /// </summary>
        public Color[,] ColourMap
        {
            get { return colorMap; }
            set { colorMap = value; }
        }
        /// <summary>
        /// specifies how to use colour washing when rendering TileMaps, default is Tile
        /// </summary>
        public TileWashMode WashMode = TileWashMode.Tile;
        /// <summary>
        /// the current position of the tilemap
        /// </summary>
        private Vector2 _position = Vector2.Zero;

        /// <summary>
        /// gets or sets the position of the tilemap
        /// </summary>
        public Vector2 Position
        {
            get { return _position; }
            set
            {
                _position = value;
                //correct for wrapping if requested
                if (WrapX)
                {
                    if (_position.X < 0) _position.X = Width - (-_position.X) % Width;
                    else if (_position.X > Width) _position.X = _position.X % Width;
                }
                if (WrapY)
                {
                    if (_position.Y < 0) _position.Y = Height - (-_position.Y) % Height;
                    else if (_position.Y > Height) _position.Y = _position.Y % Height;
                }
            }
        }
        /// <summary>
        /// gets or sets the X position of the tilemap
        /// </summary>
        public float X
        {
            get { return _position.X; }
            set
            {
                _position.X = value;
                //correct for wrapping if requested
                if (WrapX)
                {
                    if (_position.X < 0) _position.X = Width - (-_position.X) % Width;
                    else if (_position.X > Width) _position.X = _position.X % Width;

                }
            }
        }
        /// <summary>
        /// gets or sets the Y position of the tilemap
        /// </summary>
        public float Y
        {
            get { return _position.Y; }
            set
            {
                _position.Y = value;
                //correct for wrapping if requested
                if (WrapY)
                {
                    if (_position.Y < 0) _position.Y = Height - (-_position.Y) % Height;
                    else if (_position.Y > Height) _position.Y = _position.Y % Height;

                }
            }
        }
        /// <summary>
        /// holds last id generated
        /// </summary>
        static int _uniqueTileId = 0;
        /// <summary>
        /// specifies type of tilemap we have {back, middle, front, final}
        /// </summary>
        public TileMapType Type;
        /// <summary>
        /// specifies whether we can see the tilemap or not
        /// </summary>
        private Boolean _visible = false;
        /// <summary>
        /// specifies whether we can see the tilemap or not.
        /// You cannot make a tilemap visible if it has no tiles
        /// </summary>
        public Boolean Visible
        {
            get { return _visible; }
            set { 
                //only only to be set if we have columns
                if (value && this.Columns > 0 || !value)
                _visible = value; 
            }
        }
        /// <summary>
        /// if true the position of the viewport is irrelevant to the tilemap
        /// so positioning will be controlled manually
        /// </summary>
        public Boolean IgnoreViewport = false;
        /// <summary>
        /// determines whether we wrap the tilemap in both X and Y if we go outside the bounds
        /// default is no wrapping
        /// </summary>
        public Boolean Wrap { set { WrapX = WrapY = value; } }
        /// <summary>
        /// determines whether we wrap the tilemap in X if we go outside the bounds
        /// default is no wrapping
        /// </summary>
        public Boolean WrapX = false;
        /// <summary>
        /// determines whether we wrap the tilemap in Y if we go outside the bounds
        /// default is no wrapping
        /// </summary>
        public Boolean WrapY = false;
        /// <summary>
        /// Renderproperties of the tilemap you should not need to generally alter these
        /// </summary>
        public RenderProperties RenderProperties = new RenderProperties();
        /// <summary>
        /// holds the name of the tilemap
        /// </summary>
        protected string Name;
        /// <summary>
        /// unique id creator
        /// </summary>
        internal static int nameId;
        /// <summary>
        /// width of tilemap in tiles
        /// </summary>
        internal int Columns;
        /// <summary>
        /// gets the number of columns in the map
        /// </summary>
        public int ColumnCount { get { return Columns; } }
        /// <summary>
        /// height of tilemap in tiles
        /// </summary>
        internal int Rows;
        /// <summary>
        /// gets the number of rows in the map
        /// </summary>
        public int RowCount { get { return Rows; } }
        /// <summary>
        /// width of an individual tile
        /// </summary>
        internal int tileWidth;

        /// <summary>
        /// gets the width of a tile in the current map
        /// </summary>
        public int TileWidth
        {
            get { return tileWidth; }
        }
        /// <summary>
        /// height of an individual tile
        /// </summary>
        internal int tileHeight;
        /// <summary>
        /// gets the height of a tile in the current map
        /// </summary>
        public int TileHeight
        {
            get { return tileHeight; }
        }
        /// <summary>
        /// width of tilemap in pixels
        /// </summary>
        internal int Width;
        /// <summary>
        /// height if tilemap in pixels
        /// </summary>
        internal int Height;
        /// <summary>
        /// gets the area of the the tilemap, including the current X and Y displacements
        /// </summary>
        public Rectangle Area
        {
            get
            {
                    return new Rectangle(-(int)RenderProperties.Displacement.X,
                                    -(int)RenderProperties.Displacement.Y,  
                                    Width, Height);
            }
        }
        /// <summary>
        /// gets the zero positioned area of the tilemap, for comparisons with screen size
        /// </summary>
        public Rectangle Dimension
        {
            get
            {
                    return new Rectangle(0, 0, Width, Height);
            }
        }
        /// <summary>
        /// internal name of tilemap
        /// </summary>
        internal int uid;
        /// <summary>
        /// gets the unique id for this tilemap
        /// </summary>
        public int Uid
        {
            get { return uid; }
        }
        /// <summary>
        /// Provides access to the tileindex for a file based tilemap
        /// </summary>
        public string tileIndex { get; private set; }

        /// <summary>
        /// Provides a text friendly version of the TileMap (its name)
        /// </summary>
        /// <returns>The name of the tilesheet</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.AppendFormat("Tilemap:{0} dim:{6}x{7} tile:{9}x{10} drawn:{1} pos:{2} scrl:{3} x{4} sc:{5} R:{6} C:{7} A:{8}~",
                            Name,
                            drawn,
                            Position,
                            Scroll,
                            Math.Round(ScrollMultiplier,3),
                            RenderProperties.ScaleFactor,
                            RowCount,
                            ColumnCount,
                            Math.Round(Alpha, 3),
                            TileWidth,TileHeight);
            return sb.ToString();
        }
        //public string ToString(string format)
        //{
        //    return Name;
        //}
        /// <summary>
        /// Creates a new tilemap with the given area and tilesize
        /// </summary>
        /// <param name="area">The rectangular area for this tile (only the width and height matter)</param>
        /// <param name="tileSize">the width and height of each tile</param>
        public TileMap(Rectangle area, Point tileSize)
            : this("unnamed" + nameId++, area.Width, area.Height, tileSize)
        {
        }
        /// <summary>
        /// Creates a new tilemap taking the texture to set the size of the map and specifiying a specific tile size
        /// and auto tiles the texture when the tilemap is added to the tilemap manager
        /// </summary>
        /// <param name="texture">texture size specifies the width and height of the map and auto tile</param>
        /// <param name="tileSize">the width and height of each tile</param>
        /// <param name="autotile">set to true to automatically tile the texture given</param>
        public TileMap(Image /*Texture2D*/ texture, Point tileSize, bool autotile)
            : this("unnamed" + nameId++, texture.Width, texture.Height, tileSize)
        {
            if (autotile) {
                this.autotile = true; autotileTexture = texture;
                GenErrorIfUntileable(texture.Width, texture.Height, tileSize.X, tileSize.Y);
            }
        }
        /// <summary>
        /// Creates a new tilemap with the given name taking the texture to set the size of the map and specifiying a specific tile size
        /// and auto tiles the texture when the tilemap is added to the tilemap manager
        /// </summary>
        /// <param name="debugName">name for debug display</param>
        /// <param name="texture">texture size specifies the width and height of the map and auto tile</param>
        /// <param name="tileSize">the width and height of a tile in the map (use X and Y of Point)</param>
        /// <param name="autotile">set to true to automatically tile the texture given</param>
        public TileMap(String debugName, Image /*Texture2D*/ texture, Point tileSize, bool autotile)
            : this(debugName, texture.Width, texture.Height, tileSize)
        {
            if (autotile)
            {
                this.autotile = true; autotileTexture = texture;
                GenErrorIfUntileable(texture.Width, texture.Height, tileSize.X, tileSize.Y);
            }
        }

        /// <summary>
        /// Creates a new un-named tilemap same size as texture given
        /// and auto tiles the texture when the tilemap is added to the tilemap manager
        /// </summary>
        /// <param name="autotile">set to true to automatically tile the texture given</param>
        /// <param name="texture">texture size specifies the width and height of the map and auto tile</param>
        public TileMap(Image /*Texture2D*/ texture, bool autotile)
            : this("unnamed" + nameId++, texture.Width, texture.Height, new Point(defaultTileSize, defaultTileSize))
        {
            if (autotile)
            {
                this.autotile = true; autotileTexture = texture; GenErrorIfUntileable(texture.Width, texture.Height, defaultTileSize, defaultTileSize);
            }
        }
        /// <summary>
        /// Creates a new named tilemap same size as texture given
        /// and auto tiles the texture when the tilemap is added to the tilemap manager
        /// </summary>
        /// <param name="debugName">name for debug display</param>
        /// <param name="texture">texture size specifies the width and height of the map and auto tile</param>
        /// <param name="autotile">set to true to automatically tile the texture given</param>
        public TileMap(String debugName, Image /*Texture2D*/ texture, bool autotile)
            : this(debugName, texture.Width, texture.Height, new Point(defaultTileSize, defaultTileSize))
        {
            if (autotile)
            {
                this.autotile = true; autotileTexture = texture;
                GenErrorIfUntileable(texture.Width, texture.Height, defaultTileSize, defaultTileSize);
            }
        }

        /// <summary>
        /// Creates a new tilemap taking the texture to set the size of the map and specifiying a specific tile size
        /// and auto tiles the texture when the tilemap is added to the tilemap manager
        /// </summary>
        /// <param name="texture">texture size specifies the width and height of the map and auto tile</param>
        /// <param name="tileSize">the width and height of each tile</param>
        public TileMap(Image /*Texture2D*/ texture, Point tileSize)
            : this("unnamed" + nameId++, texture.Width, texture.Height, tileSize)
        { /*autotile = true; autotileTexture = texture; GenErrorIfUntileable(texture.Width, texture.Height, tileSize.X, tileSize.Y);*/
        }
        /// <summary>
        /// Creates a new tilemap with the given name taking the texture to set the size of the map and specifiying a specific tile size
        /// and auto tiles the texture when the tilemap is added to the tilemap manager
        /// </summary>
        /// <param name="debugName">name for debug display</param>
        /// <param name="texture">texture size specifies the width and height of the map and auto tile</param>
        /// <param name="tileSize">the width and height of a tile in the map (use X and Y of Point)</param>
        public TileMap(String debugName, Image /*Texture2D*/ texture, Point tileSize)
            : this(debugName, texture.Width, texture.Height, tileSize)
        {
            //autotile = true; autotileTexture = texture;
            //GenErrorIfUntileable(texture.Width, texture.Height, tileSize.X, tileSize.Y);
        }

        /// <summary>
        /// Creates a new un-named tilemap same size as texture given
        /// and auto tiles the texture when the tilemap is added to the tilemap manager
        /// </summary>
        /// <param name="texture">texture size specifies the width and height of the map and auto tile</param>
        public TileMap(Image /*Texture2D*/ texture)
            : this("unnamed" + nameId++, texture.Width, texture.Height, new Point(defaultTileSize, defaultTileSize))
        {
            //autotile = true; autotileTexture = texture; GenErrorIfUntileable(texture.Width, texture.Height, defaultTileSize, defaultTileSize);
        }
        /// <summary>
        /// Creates a new named tilemap same size as texture given
        /// and auto tiles the texture when the tilemap is added to the tilemap manager
        /// </summary>
        /// <param name="debugName">name for debug display</param>
        /// <param name="texture">texture size specifies the width and height of the map and auto tile</param>
        public TileMap(String debugName, Image /*Texture2D*/ texture)
            : this(debugName, texture.Width, texture.Height, new Point(defaultTileSize, defaultTileSize))
        {
            //autotile = true; autotileTexture = texture;
            //GenErrorIfUntileable(texture.Width, texture.Height, defaultTileSize, defaultTileSize);
        }
        /// <summary>
        /// checks to see if an auto tile texture is tileable with the given point sizes
        /// </summary>
        /// <param name="width">texture width</param>
        /// <param name="height">texture height</param>
        /// <param name="tw">tile width selected</param>
        /// <param name="th">tile height selected</param>
        private void GenErrorIfUntileable(int width, int height, int tw, int th)
        {
            return;
            //if (width % tw != 0 || height % th != 0)
            //throw new FormatException("The given texture will not tile with the given tilesize. " +
            //    "The tile width " + tw + " must divide wholly into the texture width " + width + " and " +
            //    "The tile height " + th + " must divide wholly into the texture height " + height + "."
            //    );
        }

        /// <summary>
        /// Creates a new tilemap with the given width and height in pixels using a standard tile size of 40,40
        /// </summary>
        /// <param name="debugName">name for debug display</param>
        /// <param name="width">number of pixels wide</param>
        /// <param name="height">number of pixels high</param>
        public TileMap(string debugName, int width, int height)
            : this(debugName, width, height, new Point(defaultTileSize, defaultTileSize))
        { }
        /// <summary>
        /// Creates a new tilemap with the given width and height in pixels using a standard tile size of 40,40
        /// </summary>
        /// <param name="debugName">name for debug display</param>
        /// <param name="area">specify the width and height using a rectangle</param>
        public TileMap(String debugName, Rectangle area)
            : this(debugName, area.Width, area.Height, new Point(defaultTileSize, defaultTileSize))
        { }
        /// <summary>
        /// Creates a new tilemap with the given width and height in pixels using a standard a given tile size
        /// </summary>
        /// <param name="debugName">name for debug display</param>
        /// <param name="area">specify the width and height using a rectangle</param>
        /// <param name="tileSize">the width and height of a tile in the map (use X and Y of Point)</param>
        public TileMap(String debugName, Rectangle area, Point tileSize)
            : this(debugName, area.Width, area.Height, tileSize)
        { }
        /// <summary>
        /// Creates a basic tilemap ready for a user defined tilemap to be created.
        /// You must supply the tilemap and tile data manually for this tilemap.
        /// You will also need to manually set a valid AlphaMap if you choose to use one, this must be the same dimension
        /// as the tilemap itself.
        /// </summary>
        /// <param name="debugName">Name to give the tile map</param>
        public TileMap(String debugName)
        {   
            //create unique identifier
            this.uid = _uniqueTileId++;
            _visible = true;
            //generate a unique name for layer
            this.Name = debugName;
        }
        /// <summary>
        /// creates a basic tilemap with no settings 
        /// ready to be built
        /// </summary>
        public TileMap()
        {
            //create unique identifier
            this.uid = _uniqueTileId++;
            _visible = true;
        }
        /// <summary>
        /// checks that the tile size settings are factors of the width and height of the tilemap
        /// </summary>
        private void CorrectFactor()
        {
            //check width
            while (Width % tileWidth != 0) tileWidth--;

            //check height
            while (Height % TileHeight != 0) tileHeight--;

        }
        /// <summary>
        /// Creates a new tilemap with the given area being the same as the texture and tilesize
        /// </summary>
        /// <param name="debugName"></param>
        /// <param name="width">Width of tilemap</param>
        /// <param name="height">width of tilemap</param>
        /// <param name="tileSize">width and height of individual tiles</param>
        public TileMap(string debugName, int width, int height, Point tileSize)
        {
            //generate a unique name for layer
            this.Name = debugName;
            this.Height = height;
            this.Width = width;
            this.tileWidth = tileSize.X;
            this.tileHeight = tileSize.Y;
            
            CorrectFactor();

            this.Columns = (int)((width + tileWidth * 0.5f) / tileWidth);
            this.Rows = (int)((height + tileHeight * 0.5f) / tileHeight);
            //create array to hold tile indices
            dTiles = new int[Rows, Columns];
            //unoptimistic tiles required
            myTileList = new Tile[Rows * Columns];
            ClearTiles();
            //create unique identifier
            this.uid = _uniqueTileId++;
            _visible = true;
            CreateAlphaMap();
            CreateColorMap();
        }
        /// <summary>
        /// creates a full color map for tilemap
        /// </summary>
        private void CreateColorMap()
        {
            colorMap = new Color[Rows, Columns];
            FillColourMap(Color.White);
        }
        /// <summary>
        /// fills the colour map with a specified colour
        /// </summary>
        /// <param name="fillColour">The colour to set all elements of the map to</param>
        public void FillColourMap(Color fillColour)
        {
            for (int r = 0; r < Rows; r++) for (int c = 0; c < Columns; c++) colorMap[r, c] = fillColour;
        }
        /// <summary>
        /// creates a full alpha alphamap
        /// </summary>
        private void CreateAlphaMap()
        {
            alphaMap = new float[Rows, Columns];
            FillAlphaMap(1);
        }
        /// <summary>
        /// fills the alpha map with a specified value
        /// </summary>
        /// <param name="alphaValue">The alpha value (1f opaque, 0 transparent) to set all elements of the map to</param>
        public void FillAlphaMap(float alphaValue)
        {
            for (int r = 0; r < Rows; r++) for (int c = 0; c < Columns; c++) alphaMap[r, c] = alphaValue;
        }


        /// <summary>
        /// clears tile set to no draw (-1)
        /// </summary>
        private void ClearTiles()
        {
            for (int r  = 0; r < Rows; r++)
                for (int c = 0; c < Columns; c++)
                    dTiles[r, c] = -1;
        }
        //--rendering globals
        Vector2 _draw_Position = Vector2.Zero;
        /// <summary>
        /// holds a copy of start position to draw text overlay if tile locations
        /// z holds startX, used by engine debug settings to produce overlay tile info
        /// </summary>
        internal Vector2 _draw_tile_nums_position;
        /// <summary>
        /// holds start column and row for overlay drawing
        /// </summary>
        internal Point _draw_tile_nums_coordStart;
        /// <summary>
        /// offset calculation goes here
        /// </summary>
        Vector2 _draw_offset = Vector2.Zero;
        /// <summary>
        /// loop variable for rows
        /// </summary>
        int _draw_rowCounter = 0;
        /// <summary>
        /// loop variable for columns
        /// </summary>
        int _draw_colCounter = 0;
        /// <summary>
        /// row tile to look at
        /// </summary>
        int _draw_row = 0;
        /// <summary>
        /// col tile to look at
        /// </summary>
        int _draw_col = 0;
        /// <summary>
        /// the left hand column to restart at for each row
        /// </summary>
        int _draw_col_start = 0;
        /// <summary>
        /// number of tiles high to draw based on scale
        /// </summary>
        int _draw_height = 0;
        /// <summary>
        /// number of tiles wide to draw based on scale
        /// </summary>
        int _draw_width = 0;
        float _draw_start_X = 0;
        float _draw_start_Y = 0;
        Color _draw_color;
        /// <summary>
        /// holds the tile currently being processed
        /// </summary>
        int _draw_tile = 0;
        /// <summary>
        /// debug output data is stored here
        /// </summary>
        public string debug;
        /// <summary>
        /// internal nullified rotation centre for rendering 
        /// </summary>
        Vector2 vc = Vector2.Zero;
        //--end of rendering globals
        /// <summary>
        /// draws the tilemap using the given spritebatch DOING FULL WRAP RENDERING HERE
        /// </summary>
        /// <param name="spriteBatch"></param>
        /// <param name="viewport"></param>
        internal void Draw(SpriteBatch spriteBatch, Rectangle viewport)
        {
            //divert for now
            //DrawNew(spriteBatch, viewport);
            //return;
            drawn=0;

            //do we have any map defined
            if (this._visible)
            {
                //test for extra width blocker
                if (viewport.X > 0) viewport.Width--;
                //pre-calc transparency - should do this when values change
                _draw_color = Wash;// *_alpha;
                //get number of tiles to draw for now do rough 
                //was 0.999
                _draw_height = (int)(0.999f + viewport.Height / (this.tileHeight * RenderProperties._scaleFactor));
                _draw_width = (int)(0.999f + viewport.Width / (this.tileWidth * RenderProperties._scaleFactor));

                //attempted fix for -ve viewports
                int dpx = (int)(_position.X + viewport.X * _scrollMultiplier);

                if (dpx >= 0)
                    _draw_start_X = (dpx % tileWidth) * -1;
                else
                    _draw_start_X = -1 * (tileWidth - (dpx * -1 % tileWidth));

                int dpy = (int)(_position.Y + viewport.Y * _scrollMultiplier);
                if (dpy >= 0)
                    _draw_start_Y = (dpy % tileHeight) * -1;
                else
                    _draw_start_Y = -1 * (tileHeight - (dpy * -1 % tileHeight));


                _draw_Position.Y = _draw_start_Y;

                //draw another column if we are partially drawing the first one
                if (_draw_start_X != 0) _draw_width++;
                //draw nother row if we are partially drawing the first one
                if (_draw_start_Y != 0) _draw_height++;

                //work out col and row to start drawing tiles from
                if (dpx >= 0)
                    _draw_col_start = (int)(dpx / tileWidth);
                else
                {
                    if (WrapX)
                        _draw_col_start = Columns - (((int)(dpx / tileWidth) * -1) % Columns) - 1;
                    else
                    {
                        _draw_col_start = 0;
                        _draw_start_X = -dpx;
                        _draw_width = _draw_width - (((int)(dpx / tileWidth) * -1) % Columns);
                    }
                }

                if (!WrapX)
                {
                    //correct out of bounds to right
                    if ((_draw_col_start + _draw_width) > Columns)
                        _draw_width = Columns - _draw_col_start - 1;
                }

                //correct out of bounds to right fix ??
                _draw_col_start %= Columns;


                if (dpy >= 0)
                    _draw_row = (int)(dpy / tileHeight);
                else
                {
                    if (WrapY)
                        _draw_row = Rows - (((int)(dpy / tileHeight) * -1) % Rows) - 1;
                    else
                    {
                        _draw_row = 0;
                        _draw_height = _draw_height - (((int)(dpy / tileHeight) * -1) % Rows);
                        _draw_Position.Y = -dpy;
                    }
                }

                if (!WrapY)
                {
                    //correct for out of bounds to bottom
                    if ((_draw_row + _draw_height) > Rows) _draw_height = Rows - _draw_row - 1;
                }

                                //correct out of bounds fix??
                _draw_row = _draw_row % Rows;

                //attempt to do displacement
                _draw_start_X -= RenderProperties.Displacement.X;
                _draw_Position.Y -= RenderProperties.Displacement.Y;
                //copy for overlay rendering if req'd
                _draw_tile_nums_position.X = _draw_start_X;
                _draw_tile_nums_position.Y = _draw_Position.Y;
                _draw_tile_nums_coordStart.X = _draw_col_start;
                _draw_tile_nums_coordStart.Y = _draw_row;

                //render using appropriate method
                switch (WashMode)
                {
                    case TileWashMode.Tile:
                        if (!UseAlphaMap)
                        {
                            for (_draw_rowCounter = 0; _draw_rowCounter <= _draw_height; _draw_rowCounter++)
                            {
                                _draw_Position.X = _draw_start_X;
                                _draw_col = _draw_col_start; // NEED TO PICK CORRECT START COLUMN
                                //wrapping if requested
                                if (_draw_row == Rows) _draw_row = 0;
                                for (_draw_colCounter = 0; _draw_colCounter <= _draw_width; _draw_colCounter++)
                                {
                                    //wrapping if requested
                                    if (_draw_col == Columns) _draw_col = 0;
                                    //empty tile should be -1
                                    if ((_draw_tile = this.dTiles[_draw_row, _draw_col]) >= 0)
                                    {
                                        drawn++;
                                        spriteBatch.Draw(myTileList[_draw_tile].texture,
                                            _draw_Position, this.myTileList[_draw_tile].portion,
                                            this.myTileList[_draw_tile].wash * _alpha);
                                    }

                                    _draw_Position.X = _draw_Position.X + tileWidth;
                                    _draw_col = _draw_col + 1;
                                }//colCounter
                                _draw_Position.Y = _draw_Position.Y + tileHeight;
                                _draw_row = _draw_row + 1;
                            }//rowCounter
                        }
                        else//use alphaMap
                        {
                            for (_draw_rowCounter = 0; _draw_rowCounter <= _draw_height; _draw_rowCounter++)
                            {
                                _draw_Position.X = _draw_start_X;
                                _draw_col = _draw_col_start; // NEED TO PICK CORRECT START COLUMN
                                //wrapping if requested
                                if (_draw_row == Rows) _draw_row = 0;
                                for (_draw_colCounter = 0; _draw_colCounter <= _draw_width; _draw_colCounter++)
                                {
                                    //wrapping if requested
                                    if (_draw_col == Columns) _draw_col = 0;
                                    //empty tile should be -1
                                    if ((_draw_tile = this.dTiles[_draw_row, _draw_col]) >= 0)
                                    {
                                        drawn++;

                                        spriteBatch.Draw(myTileList[_draw_tile].texture,
                                            _draw_Position, this.myTileList[_draw_tile].portion,
                                            this.myTileList[_draw_tile].wash * this.alphaMap[_draw_row, _draw_col]);
                                    }

                                    _draw_Position.X = _draw_Position.X + tileWidth;
                                    _draw_col = _draw_col + 1;
                                }//colCounter
                                _draw_Position.Y = _draw_Position.Y + tileHeight;
                                _draw_row = _draw_row + 1;
                            }//rowCounter
                        }

                        break;
                    case TileWashMode.Global:
                        _draw_color = this.Wash * this._alpha;
                        if (!UseAlphaMap)
                        {
                            for (_draw_rowCounter = 0; _draw_rowCounter <= _draw_height; _draw_rowCounter++)
                            {
                                _draw_Position.X = _draw_start_X;
                                _draw_col = _draw_col_start; // NEED TO PICK CORRECT START COLUMN
                                //wrapping if requested
                                if (_draw_row == Rows) _draw_row = 0;
                                for (_draw_colCounter = 0; _draw_colCounter <= _draw_width; _draw_colCounter++)
                                {
                                    //wrapping if requested
                                    if (_draw_col == Columns) _draw_col = 0;
                                    //empty tile should be -1
                                    if ((_draw_tile = this.dTiles[_draw_row, _draw_col]) >= 0)
                                    {
                                        drawn++;

                                        spriteBatch.Draw(myTileList[_draw_tile].texture,
                                            _draw_Position, this.myTileList[_draw_tile].portion,
                                            _draw_color);
                                    }

                                    _draw_Position.X = _draw_Position.X + tileWidth;
                                    _draw_col = _draw_col + 1;
                                }//colCounter
                                _draw_Position.Y = _draw_Position.Y + tileHeight;
                                _draw_row = _draw_row + 1;
                            }//rowCounter
                        }
                        else//use alphaMap
                        {
                            for (_draw_rowCounter = 0; _draw_rowCounter <= _draw_height; _draw_rowCounter++)
                            {
                                _draw_Position.X = _draw_start_X;
                                _draw_col = _draw_col_start; // NEED TO PICK CORRECT START COLUMN
                                //wrapping if requested
                                if (_draw_row == Rows) _draw_row = 0;
                                for (_draw_colCounter = 0; _draw_colCounter <= _draw_width; _draw_colCounter++)
                                {
                                    //wrapping if requested
                                    if (_draw_col == Columns) _draw_col = 0;
                                    //empty tile should be -1
                                    if ((_draw_tile = this.dTiles[_draw_row, _draw_col]) >= 0)
                                    {
                                        drawn++;

                                        spriteBatch.Draw(myTileList[_draw_tile].texture,
                                            _draw_Position, this.myTileList[_draw_tile].portion,
                                            this.Wash * this.alphaMap[_draw_row, _draw_col]);
                                    }

                                    _draw_Position.X = _draw_Position.X + tileWidth;
                                    _draw_col = _draw_col + 1;
                                }//colCounter
                                _draw_Position.Y = _draw_Position.Y + tileHeight;
                                _draw_row = _draw_row + 1;
                            }//rowCounter
                        }
                        break;
                    case TileWashMode.ColourMap:
                        if (!UseAlphaMap)
                        {
                            for (_draw_rowCounter = 0; _draw_rowCounter <= _draw_height; _draw_rowCounter++)
                            {
                                _draw_Position.X = _draw_start_X;
                                _draw_col = _draw_col_start; // NEED TO PICK CORRECT START COLUMN
                                //wrapping if requested
                                if (_draw_row == Rows) _draw_row = 0;
                                for (_draw_colCounter = 0; _draw_colCounter <= _draw_width; _draw_colCounter++)
                                {
                                    //wrapping if requested
                                    if (_draw_col == Columns) _draw_col = 0;
                                    //empty tile should be -1
                                    if ((_draw_tile = this.dTiles[_draw_row, _draw_col]) >= 0)
                                    {
                                        drawn++;

                                        spriteBatch.Draw(myTileList[_draw_tile].texture,
                                            _draw_Position, this.myTileList[_draw_tile].portion,
                                            colorMap[_draw_row, _draw_col] * _alpha);
                                    }
                                    _draw_Position.X = _draw_Position.X + tileWidth;
                                    _draw_col = _draw_col + 1;
                                }//colCounter
                                _draw_Position.Y = _draw_Position.Y + tileHeight;
                                _draw_row = _draw_row + 1;
                            }//rowCounter
                        }
                        else//use alphaMap
                        {
                            for (_draw_rowCounter = 0; _draw_rowCounter <= _draw_height; _draw_rowCounter++)
                            {
                                _draw_Position.X = _draw_start_X;
                                _draw_col = _draw_col_start; // NEED TO PICK CORRECT START COLUMN
                                //wrapping if requested
                                if (_draw_row == Rows) _draw_row = 0;
                                for (_draw_colCounter = 0; _draw_colCounter <= _draw_width; _draw_colCounter++)
                                {
                                    //wrapping if requested
                                    if (_draw_col == Columns) _draw_col = 0;
                                    //empty tile should be -1
                                    if ((_draw_tile = this.dTiles[_draw_row, _draw_col]) >= 0)
                                    {
                                        drawn++;

                                        spriteBatch.Draw(myTileList[_draw_tile].texture,
                                            _draw_Position, this.myTileList[_draw_tile].portion,
                                            colorMap[_draw_row, _draw_col] * this.alphaMap[_draw_row, _draw_col]);
                                    }

                                    _draw_Position.X = _draw_Position.X + tileWidth;
                                    _draw_col = _draw_col + 1;
                                }//colCounter
                                _draw_Position.Y = _draw_Position.Y + tileHeight;
                                _draw_row = _draw_row + 1;
                            }//rowCounter
                        }
                        break;
                }
            }//if visible
        }//end sub draw
        /// <summary>
        /// checks to make sure that you have supplied enough tiles for the tilemap presented.
        /// An exception will be throw showing how many more tiles you need to define
        /// This should only be used for file based created tile maps
        /// </summary>
        public void CheckValidTileSet()
        {
            
            if (tileIndex.Length > myTileList.Length)
            {
                throw new ArgumentException(
                    "Your tilemap defines " + tileIndex.Length + " tiles, which are " + tileIndex + " but you only defined " + myTileList.Length + " tiles" +
                    " in your tile list\nYou need to add a further " + (tileIndex.Length - myTileList.Length) + " tiles to your tilelist\nuse new Tile(Tex.Rectangle50by50, TileRectangleSize, Color.Red) to specify a placeholder if none exist"
                    );
            }
        }
        /// <summary>
        /// specifies the default rectangle size for tiles, to be used when defining color based temporary tiles
        /// </summary>
        public Rectangle TileRectangleSize { get { return new Rectangle(0, 0, tileWidth, tileHeight); } }
        /// <summary>
        /// determines if tile information should be shown on top of tilemap.
        /// This is very expensive so only use for debugging
        /// </summary>
        public bool OverlayShow = false;
        /// <summary>
        /// how many columns,rows to skip display of, normally 1 which shows all.
        /// set to 2 to show every other row, column can be used with small tile tilemaps.
        /// Keep to factors of 2
        /// </summary>
        public int OverlaySkip = 1;
        /// <summary>
        /// determines render size for system font
        /// </summary>
        public float OverlayScale = 1f;
        /// <summary>
        /// specifies colour of the overlay text
        /// </summary>
        public Color OverlayColor = Color.White;
        /// <summary>
        /// holds text attribute for rendering ovelay
        /// </summary>
        TextAtt overlayAtt = new TextAtt(1, 1, Color.White, Align.topLeft);
        /// <summary>
        /// specifies what information should be overlayed
        /// </summary>
        public TileMapOverlay OverlayOutput = TileMapOverlay.coordinates;
        /// <summary>
        /// called by debug system of engine
        /// </summary>
        /// <param name="tm">text manager who is going to draw these items</param>
        /// <param name="f">font to use</param>
        /// <param name="em">ref to enginemanager</param>
        internal void DrawOverlay(TextManager tm, FontSprite f, EngineManager em)
        {
            //must calculate the render metrics if we are not showing this tilemap
            
            if (!Visible)
            {
                Rectangle viewport = em.viewport[this.RenderProperties.ViewAssociation[0]].viewport.Bounds;
                //test for extra width blocker
                if (viewport.X > 0) viewport.Width--;
                //pre-calc transparency - should do this when values change
                _draw_color = Wash;// *_alpha;
                //get number of tiles to draw for now do rough 
                //was 0.999
                _draw_height = (int)(0.999f + viewport.Height / (this.tileHeight * RenderProperties._scaleFactor));
                _draw_width = (int)(0.999f + viewport.Width / (this.tileWidth * RenderProperties._scaleFactor));

                //attempted fix for -ve viewports
                int dpx = (int)(_position.X + viewport.X * _scrollMultiplier);

                if (dpx >= 0)
                    _draw_start_X = (dpx % tileWidth) * -1;
                else
                    _draw_start_X = -1 * (tileWidth - (dpx * -1 % tileWidth));

                int dpy = (int)(_position.Y + viewport.Y * _scrollMultiplier);
                if (dpy >= 0)
                    _draw_start_Y = (dpy % tileHeight) * -1;
                else
                    _draw_start_Y = -1 * (tileHeight - (dpy * -1 % tileHeight));


                _draw_Position.Y = _draw_start_Y;

                //draw another column if we are partially drawing the first one
                if (_draw_start_X != 0) _draw_width++;
                //draw nother row if we are partially drawing the first one
                if (_draw_start_Y != 0) _draw_height++;

                //work out col and row to start drawing tiles from
                if (dpx >= 0)
                    _draw_col_start = (int)(dpx / tileWidth);
                else
                {
                    if (WrapX)
                        _draw_col_start = Columns - (((int)(dpx / tileWidth) * -1) % Columns) - 1;
                    else
                    {
                        _draw_col_start = 0;
                        _draw_start_X = -dpx;
                        _draw_width = _draw_width - (((int)(dpx / tileWidth) * -1) % Columns);
                    }
                }

                if (!WrapX)
                {
                    //correct out of bounds to right
                    if ((_draw_col_start + _draw_width) > Columns)
                        _draw_width = Columns - _draw_col_start - 1;
                }

                //correct out of bounds to right fix ??
                _draw_col_start %= Columns;


                if (dpy >= 0)
                    _draw_row = (int)(dpy / tileHeight);
                else
                {
                    if (WrapY)
                        _draw_row = Rows - (((int)(dpy / tileHeight) * -1) % Rows) - 1;
                    else
                    {
                        _draw_row = 0;
                        _draw_height = _draw_height - (((int)(dpy / tileHeight) * -1) % Rows);
                        _draw_Position.Y = -dpy;
                    }
                }

                if (!WrapY)
                {
                    //correct for out of bounds to bottom
                    if ((_draw_row + _draw_height) > Rows) _draw_height = Rows - _draw_row - 1;
                }

                //correct out of bounds fix??
                _draw_row = _draw_row % Rows;

                //attempt to do displacement
                _draw_start_X -= RenderProperties.Displacement.X;
                _draw_Position.Y -= RenderProperties.Displacement.Y;
                //copy for overlay rendering if req'd
                _draw_tile_nums_position.X = _draw_start_X;
                _draw_tile_nums_position.Y = _draw_Position.Y;
            }


            //set attribute items
            overlayAtt.Scale = OverlayScale;
            overlayAtt.Colour = OverlayColor;
            string output = "";
            _draw_Position.Y = _draw_tile_nums_position.Y;
            _draw_row = _draw_tile_nums_coordStart.Y;

            for (_draw_rowCounter = 0; _draw_rowCounter <= _draw_height; _draw_rowCounter+=OverlaySkip)
            {
                _draw_Position.X = _draw_tile_nums_position.X;
                _draw_col = _draw_tile_nums_coordStart.X;// _draw_col_start; // should already have been calculated
                //wrapping if requested
                if (_draw_row >= Rows)
                    _draw_row -= Rows;
                for (_draw_colCounter = 0; _draw_colCounter <= _draw_width; _draw_colCounter += OverlaySkip)
                {
                    //wrapping if requested
                    if (_draw_col >= Columns)
                        _draw_col -= Columns;
                    
                    switch (OverlayOutput)
                    {
                        case TileMapOverlay.alphavalue:output = this.alphaMap[_draw_row, _draw_col].ToString("0.00");break;
                        case TileMapOverlay.coordinates:output = _draw_col + "," + _draw_row;break;
                        case TileMapOverlay.contents:output = this.dTiles[_draw_row, _draw_col].ToString();break;
                        case TileMapOverlay.collisionContents:
                            if (cTiles != null)
                                output = this.cTiles[_draw_row, _draw_col].ToString();
                            else
                                output = "UD";
                                break;
                    }
                    tm.DrawQuick(f, output, _draw_Position.X, _draw_Position.Y, overlayAtt);

                    _draw_Position.X = _draw_Position.X + tileWidth * OverlaySkip;
                    _draw_col = _draw_col + OverlaySkip;
                }//colCounter
                _draw_Position.Y = _draw_Position.Y + tileHeight * OverlaySkip;
                _draw_row = _draw_row + OverlaySkip;
            }//rowCounter
        }

        /// <summary>
        /// number of tiles drawn during last pass
        /// </summary>
        public int drawn = 0;
        /// <summary>
        /// specifies virtual width of viewport based on scale
        /// </summary>
        private Vector2 virtualView = Vector2.Zero;

        /// <summary>
        /// new version of draw routine
        /// </summary>
        /// <param name="spriteBatch"></param>
        /// <param name="viewport"></param>
        internal void DrawNew(SpriteBatch spriteBatch, Rectangle viewport)
        {
            //do we have any map defined
            if (this._visible)
            {
                drawn = 0;
                //test for extra width blocker
                if (viewport.X > 0) viewport.Width--;
                virtualView.X = viewport.Width / RenderProperties._scaleFactor;
                virtualView.Y = viewport.Height / RenderProperties._scaleFactor;

                //pre-calc transparency - should do this when values change
                _draw_color = Wash * _alpha;
                //holds thr size of the virtual tiles 
                //virtualTile.X = this.tileHeight * RenderProperties._scaleFactor;
                //virtualTile.Y = this.tileHeight * RenderProperties._scaleFactor;
                //get number of tiles to draw for now do rough 
                //was 0.999

                _draw_width = (int)(virtualView.X / tileWidth);
                _draw_height = (int)(virtualView.Y / tileHeight);

                if (virtualView.X % tileWidth != 0) _draw_width++;
                if (virtualView.Y % tileHeight != 0) _draw_height++;
                //_draw_width = RenderProperties._scaleFactor;
                //_draw_height *= RenderProperties._scaleFactor;

                _draw_start_X = ((_position.X + viewport.X * _scrollMultiplier) % tileWidth) * -1;
                _draw_start_Y = ((_position.Y + viewport.Y * _scrollMultiplier) % tileHeight) * -1;
                _draw_Position.Y = _draw_start_Y;

                //draw another column if we are partially drawing the first one
                if (_draw_start_X != 0) _draw_width++;
                //draw nother row if we are partially drawing the first one
                if (_draw_start_Y != 0) _draw_height++;

                ////adjust draw height and draw width based on scale being used
                //if (RenderProperties.ScaleFactor != 1)
                //{
                //    //need another calc so we can determine algebraically how many tiles needs for a specific render size
                //    _draw_width = (int)(_draw_width / RenderProperties.ScaleFactor) + 1;
                //    _draw_height = (int)(_draw_height / RenderProperties.ScaleFactor) + 1;
                //}

                //work out col and row to start drawing tiles from
                _draw_col_start = (int)((_position.X + viewport.X * _scrollMultiplier) / tileWidth);
                _draw_row = (int)((_position.Y + viewport.Y * _scrollMultiplier) / tileHeight);
                //_draw_col_start = (int)((_position.X + viewport.X * _scrollMultiplier) / tileWidth);
                //_draw_row = (int)((_position.Y + viewport.Y * _scrollMultiplier) / tileHeight);

                //only going to happen if Wrapping is false
                if (!WrapX)
                {
                    if (_draw_col_start < 0)
                    {
                        //adjust offset and counter number of tiles wide to draw
                        _draw_start_X = _draw_start_X - _draw_col_start * tileWidth;
                        _draw_width = _draw_width + _draw_col_start;
                        _draw_col_start = 0;
                    }
                    //correct out of bounds to right
                    if ((_draw_col_start + _draw_width) > Columns)
                        _draw_width = Columns - _draw_col_start - 1;
                    //_draw_col_start = _draw_col_start % Columns;
                }
                //correct out of bounds to right fix ??
                _draw_col_start %= Columns;

                if (!WrapY)
                {
                    if (_draw_row < 0)
                    {
                        //adjust offset and counter number of tiles wide to draw
                        _draw_Position.Y = _draw_Position.Y - _draw_row * tileHeight;
                        _draw_height = _draw_height + _draw_row;
                        _draw_row = 0;
                    }

                    //correct for out of bounds to bottom
                    if ((_draw_row + _draw_height) > Rows) _draw_height = Rows - _draw_row - 1;
                    //_draw_row = _draw_row % Rows;
                }
                //correct out of bounds fix??
                _draw_row = _draw_row % Rows;

                ////positive wrap asumes we want to wrap
                ////AGAIN SHOULDN'T NEED THIS
                ////SHOULD ONLY NEED THIS IF WRAPPING IS FALSE
                //_draw_row = (int)((_position.Y + viewport.Y * _scrollMultiplier) / tileHeight);
                ////correct for out of bounds to right
                //_draw_row = _draw_row % Rows;

                //attempt to do displacement
                _draw_start_X -= RenderProperties.Displacement.X;
                _draw_Position.Y -= RenderProperties.Displacement.Y;
#if DEBUG
                debug = "draw start:" + _draw_start_X.ToString() + " col start:" + _draw_col_start.ToString() + " drawcol:" + _draw_width;
#endif
                for (_draw_rowCounter = 0; _draw_rowCounter <= _draw_height; _draw_rowCounter++)
                {
                    _draw_Position.X = _draw_start_X;
                    _draw_col = _draw_col_start; // NEED TO PICK CORRECT START COLUMN
                    //wrapping if requested
                    if (_draw_row == Rows)
                        _draw_row = 0;
                    for (_draw_colCounter = 0; _draw_colCounter <= _draw_width; _draw_colCounter++)
                    {
                        //wrapping if requested
                        if (_draw_col == Columns)
                            _draw_col = 0;
                        //empty tile should be -1
                        if ((_draw_tile = this.dTiles[_draw_row, _draw_col]) >= 0)
                        {
                            drawn++;
                            //normal
                            spriteBatch.Draw(
                                myTileList[_draw_tile].texture,
                                _draw_Position, this.myTileList[_draw_tile].portion,
                                _draw_color);
                            //layer depth
                            //spriteBatch.Draw(myTileList[_draw_tile].texture,
                            //    _draw_Position,
                            //    this.myTileList[_draw_tile].portion,
                            //    _draw_color, 0, Vector2.Zero, 1, SpriteEffects.None, 0.1f);
                        }

                        _draw_Position.X = _draw_Position.X + tileWidth;
                        _draw_col = _draw_col + 1;
                        ////wrapping if requested
                        //if (_draw_col == Columns)
                        //    _draw_col = 0;
                    }//colCounter
                    _draw_Position.Y = _draw_Position.Y + tileHeight;
                    _draw_row = _draw_row + 1;
                    ////wrapping if requested
                    //if (_draw_row == Rows)
                    //    _draw_row = 0;
                }//rowCounter
            }//if visible
        }//end sub draw


        /// <summary>
        /// moves the tilemap over the specified period of time
        /// </summary>
        /// <param name="period">the fraction of a second we are dealing with for this update</param>
        internal void MoveBy(ref float period)
        {
            _position.X = _position.X + _scrollAmount.X * period;
            _position.Y = _position.Y + _scrollAmount.Y * period;

            //correct for wrapping if requested
            if (WrapX)
            {
                if (_position.X < 0) _position.X = Width - (-_position.X) % Width;
                    //same for y (tilemap002) should this be how it is in the commented out section (check tomorrow)
                else if (_position.X > Width) _position.X = _position.X % Width;
            }
            if (WrapY)
            {
                if (_position.Y < 0) _position.Y = Height - (-_position.Y) % Height;
                else if (_position.Y > Height) _position.Y = _position.Y % Height;
            }
            //wrap checks if we are doing that
            //if (Wrap)
            //{
            //    if (_position.X < 0) _position.X = _position.X + Width;
            //    else if (_position.X > Width) _position.X = _position.X - Width;
            //    if (_position.Y < 0) _position.Y = _position.Y + Height;
            //    else if (_position.Y > Height) _position.Y = _position.Y - Height;
            //}
        }

        /// <summary>
        /// attempts to add an individual tile to the tile list for the tilemap
        /// if it already exist then this will be rejected and the index returned
        /// </summary>
        /// <param name="texture">texture of tile</param>
        /// <param name="rect">rectangluar portion of the texture for this tile</param>
        /// <returns>the index of the new tile or the existing index if this is a duplicate</returns>
        internal int AddTile(Image /*Texture2D*/ texture, Rectangle rect)
        {
            int i = TileExists(texture, rect);
            if (i == -1)
            {
                i = tileCount;
                myTileList[tileCount] = new Tile(texture, rect);
                tileCount++;
            }
            return i;
        }

        /// <summary>
        /// attempt to locate a tile in the tilemaps list
        /// </summary>
        /// <param name="texture">texture to look for</param>
        /// <param name="rect">rectangle to see if exist</param>
        /// <returns>-1 if tile not found or tile index if already generated</returns>
        private int TileExists(Image /*Texture2D*/ texture, Rectangle rect)
        {
            int found = -1;
            for (int i = 0; i < tileCount; i++)
            {
                if (myTileList[i].texture == texture && myTileList[i].portion == rect)
                {
                    found = i;
                    break;
                }
            }
            return found;
        }

        /// <summary>
        /// gets the location of a tile from the given tile location and direction
        /// </summary>
        /// <param name="startingPoint">tile location to retrieve</param>
        /// <param name="direction">TileMap.Left, TileMap.Right, TileMap.Right, TileMap.Down</param>
        /// <param name="distance">tile offset</param>
        /// <returns>tile location or point with -1,-1 if no direction is picked</returns>
        public Point Location(Point startingPoint, int direction, int distance)
        {
            switch (direction)
            {
                case LEFT: return new Point(startingPoint.X - distance, startingPoint.Y);
                case RIGHT: return new Point(startingPoint.X + distance, startingPoint.Y);
                case UP: return new Point(startingPoint.X, startingPoint.Y - distance);
                case DOWN: return new Point(startingPoint.X, startingPoint.Y + distance);
                case UP_LEFT: return new Point(startingPoint.X - distance, startingPoint.Y - distance);
                case UP_RIGHT: return new Point(startingPoint.X + distance, startingPoint.Y - distance);
                case DOWN_LEFT: return new Point(startingPoint.X - distance, startingPoint.Y + distance);
                case DOWN_RIGHT: return new Point(startingPoint.X + distance, startingPoint.Y + distance);
                default: return new Point(-1, -1); 
            }
        }
        /// <summary>
        /// specifies if search and direction helpers should generate NE, NW, SE and SW directions
        /// </summary>
        public bool MinorOrdinals = false;

        /// <summary>
        /// returns true of a given tile location is actually within the tilemap
        /// </summary>
        /// <param name="tile">the tile to check</param>
        /// <returns>true if located in the map, false otherwise</returns>
        public bool ValidTile(Point tile)
        {
            return (tile.X >= 0 &&
                tile.X < Columns &&
                tile.Y >= 0 &&
                tile.Y < Rows) ;
        }
        /// <summary>
        /// returns a list of tile locations for a given position and any number of offsets
        /// These can then be processed
        /// </summary>
        /// <param name="basePosition">A 2d position to add to each offset</param>
        /// <param name="offsets">a list of positions to combine with the basePosition to determine a tile location</param>
        /// <returns>A list of unique locations</returns>
        public List<Point> Location(Vector2 basePosition, List<Vector2> offsets)
        {
            List<Point> uniqueLocations = new List<Point>();
            foreach (Vector2 offset in offsets)
            {
                Point location = Location(basePosition.X + offset.X, basePosition.Y + offset.Y);
                if (!uniqueLocations.Contains(location))
                    uniqueLocations.Add(location);
            }
            return uniqueLocations;
        }
        /// <summary>
        /// returns the tile that the given pixel location would occupy.
        /// If the position is out of bounds then a tile at the extremety will be returned
        /// This may change in a future version
        /// </summary>
        /// <param name="x">X position to use</param>
        /// <param name="y">Y position to use</param>
        /// <returns>A tile location</returns>
        public Point Location(float x, float y)
        {
            //factor out the displacement of the layer if set
            x = x + RenderProperties.Displacement.X;
            y = y + RenderProperties.Displacement.Y;
            
            //clamp to edge of map
            if (ClampTileLocation)
            {
                if (x < 0) x = 0; else if (x >= Width) x = Width - 1;
                if (y < 0) y = 0; else if (y >= Height) y = Height - 1;
            }

            //adjusting width based on scale factor 7.0.2.15 fix attempt - sort of works
            return new Point((int)(x / (tileWidth * RenderProperties._scaleFactor)), (int)(y / (tileHeight * RenderProperties._scaleFactor)));
        }

        /// <summary>
        /// if true instructs the tile map to clamp any TileLocation checks. Default is true
        /// if set to false you will need to check to make sure tile locations are usable using ValidTile()
        /// (as they may be outside your valid tile locations)
        /// </summary>
        public bool ClampTileLocation = true;

        /// <summary>
        /// returns location of the centre of an actor
        /// </summary>
        /// <param name="actor">the sprite to determine the tile location of its centre</param>
        /// <returns>A tile location</returns>
        public Point Location(Sprite actor)
        {
            return Location(actor.Centre2D.X, actor.Centre2D.Y);
        }

        /// <summary>
        /// gets the centre of a tile as a vector2
        /// </summary>
        /// <param name="location">the tile to investigate</param>
        /// <returns>the position of its centre</returns>
        public Vector2 PixelLocationCentre(Point location)
        {
            return new Vector2(
                location.X * tileWidth - RenderProperties.Displacement.X + tileWidth * 0.5f,
                location.Y * tileHeight - RenderProperties.Displacement.Y + tileHeight * 0.5f);
        }
        /// <summary>
        /// gets the x position of the centre of a tile
        /// </summary>
        /// <param name="location">the tile to investigate</param>
        /// <returns>the x position of the centre</returns>
        public float PixelLocationCentreX(Point location)
        {
            return location.X * tileWidth - RenderProperties.Displacement.X + tileWidth * 0.5f;
        }
        /// <summary>
        /// gets the y position of the centre of a tile
        /// </summary>
        /// <param name="location">the tile to investigate</param>
        /// <returns>the y position of the centre</returns>
        public float PixelLocationCentreY(Point location)
        {
            return location.Y * tileHeight - RenderProperties.Displacement.Y + tileHeight * 0.5f;
        }

        /// <summary>
        /// Returns a pixel position based on a tile (upper left corner)
        /// </summary>
        /// <param name="location">The tile to get coords of</param>
        /// <returns>A zero z valued position of the tile</returns>
        public Vector2 PixelLocationTopLeft(Point location)//was PositionFromTile
        {
            return new Vector2(
                location.X * tileWidth - RenderProperties.Displacement.X,
                location.Y * tileHeight - RenderProperties.Displacement.Y);
        }
        /// <summary>
        /// gets the X position of a given tile (the left hand side)
        /// </summary>
        /// <param name="location">tile to examine</param>
        /// <returns>left hand side</returns>
        public float PixelLocationLeft(Point location)
        { return location.X * tileWidth - RenderProperties.Displacement.X; }

        /// <summary>
        /// gets the right hand position of a given tile
        /// </summary>
        /// <param name="location">tile to examine</param>
        /// <returns>right hand side</returns>
        public float PixelLocationRight(Point location)
        {
            return (location.X + 1) * tileWidth - RenderProperties.Displacement.X - 1;
        }
        /// <summary>
        /// gets the bottom position of a given tile
        /// </summary>
        /// <param name="location">tile to examine</param>
        /// <returns>bottom of the tile</returns>
        public float PixelLocationBottom(Point location)
        { return (location.Y + 1) * tileHeight - RenderProperties.Displacement.Y - 1; }

        /// <summary>
        /// gets the y position of a given tile (the top of the tile)
        /// </summary>
        /// <param name="location">tile to examine</param>
        /// <returns>top of the tile</returns>
        public float PixelLocationTop(Point location)
        { return location.Y * tileHeight - RenderProperties.Displacement.Y; }
        public float PixelLocationTop(Point location, float horizontalOffset)
        {
            Tile t = MyTileList[Map[location.Y, location.X]];
            
            return t.LerpTopPosition(horizontalOffset, PixelLocationTopLeft(location)) - RenderProperties.Displacement.Y; }

        /// <summary>
        /// places a sprite at the specific tile location
        /// the alignment of the sprite needs to be taken into account
        /// </summary>
        /// <param name="s">the sprite to position</param>
        /// <param name="location">the tile to use for positioning</param>
        public void SetActorAt(Sprite s, Point location)
        {
            s.Position.X = location.X * tileWidth - RenderProperties.Displacement.X;
            s.Position.Y = location.Y * tileHeight - RenderProperties.Displacement.Y;
        }
        /// <summary>
        /// places the bottom centre of a sprite at the top of a specific tile location
        /// taking into account any slope information of the tile
        /// this does not affect the x position of the sprite
        /// </summary>
        /// <param name="s">the sprite to position</param>
        /// <param name="location">the tile to use for positioning</param>
        public void SetActorAtTop(Sprite s, Point location)
        {
            SetActorAtTop(s, s.Centre2D.X, location);
        }
        /// <summary>
        /// places the bottom of a sprite at the top of a specific tile location
        /// taking into account any slope information of the tile
        /// this does not affect the x position of the sprite, but will use the horizontal position given 
        /// as a marker for penetration of the tile (for slope testing)
        /// </summary>
        /// <param name="s">the sprite to position</param>
        /// <param name="horizontalPosition">The position to test along the slope of the tile</param>
        /// <param name="tile">the tile to use for positioning</param>
        public void SetActorAtTop(Sprite s, float horizontalPosition, Point tile)
        {
            SetActorAtTop(s, horizontalPosition, tile, 0);
            ////pick up tile data
            //Tile t = myTileList[GetGraphic(tile)];
            //if (t != null)
            //{
            //    float ytop = t.LerpTopPosition(horizontalPosition, PixelLocationTopLeft(tile));
            //    SpriteHelper.AlignBottomAt(s, ytop);
            //}
        }
        /// <summary>
        /// places the bottom of a sprite at the top of a specific tile location
        /// taking into account any slope information of the tile
        /// this does not affect the x position of the sprite, but will use the horizontal position given 
        /// as a marker for penetration of the tile (for slope testing)
        /// </summary>
        /// <param name="s">the sprite to position</param>
        /// <param name="horizontalPosition">The position to test along the slope of the tile</param>
        /// <param name="tile">the tile to use for positioning</param>
        /// <param name="verticalOffset">An offset value to either sink (+ve) or float -ve the sprite into tile top</param>
        public void SetActorAtTop(Sprite s, float horizontalPosition, Point tile, float verticalOffset)
        {
            //pick up tile data
            Tile t = myTileList[GetGraphic(tile)];
            if (t != null)
            {
                float ytop = t.LerpTopPosition(horizontalPosition, PixelLocationTopLeft(tile));
                SpriteHelper.AlignBottomAt(s, ytop, verticalOffset);
            }
        }
        /// <summary>
        /// will attempt to sit an actor on top of graphic tile given. If this sprite is moving down and the tolerance with the top is ok
        /// then the sprites bottom will be placed on top of the tile. This will work with sloping tiles as well
        /// You must already have determined collision with a tile first before attempting to do this.
        /// </summary>
        /// <param name="s">The sprite to attempt to sit</param>
        /// <param name="mytile">The tile to potentially sit on</param>
        /// <param name="xCentre">the x position to use as the sprite centre (only useful for sloping tiles)</param>
        /// <param name="depthTolerance">The pixel distance from top of tile to assume on top</param>
        /// <param name="passableTiles">A list of tiles considered movable on, this should contain empty -1 at least</param>
        /// <param name="verticalOffset">An offset value from centre of sprite to act as the bottom, if this is smaller than half the height of the sprite it will sink into tile top</param>
        /// <returns>true if sprite was aligned to top of tile, false if it wasn't considered to be on top</returns>
        public bool SetActorOnGraphicTile(Sprite s, Point mytile, float xCentre, float verticalOffset, float depthTolerance, List<int> passableTiles)
        {
            //work out centre based offset in relation to bottom of sprite
            verticalOffset -= s.VisibleHeightDiv2;
            float dist = s.Bottom + verticalOffset - PixelLocationTop(mytile);
            if (s.MovedDown && dist < depthTolerance)
            {
                //check for tile above to make sure it's not unavailable
                int tileabove = GetGraphic(Location(mytile, TileMap.UP, 1));
                if (passableTiles.Contains(tileabove))
                {
                    SetActorAtTop(s, xCentre, mytile, verticalOffset);
                    s.Velocity.Y = 0;
                    return true;
                }
            }
            return false;
        }
        /// <summary>
        /// will attempt to sit an actor on top of collision tile given. If this sprite is moving down and the tolerance with the top is ok
        /// then the sprites bottom will be placed on top of the tile. 
        /// You must already have determined collision with a tile first before attempting to do this.
        /// </summary>
        /// <param name="s">The sprite to attempt to sit</param>
        /// <param name="mytile">The tile to potentially sit on</param>
        /// <param name="xCentre">the x position to use as the sprite centre 
        /// <param name="verticalOffset">An offset value to either sink (+ve) or float -ve the sprite into tile top</param>
        /// <param name="depthTolerance">The pixel distance from top of tile to assume on top</param>
        /// <param name="passableTiles">A list of tiles considered movable on, this should contain empty 0 at least</param>
        /// <returns>true if sprite was aligned to top of tile, false if it wasn't considered to be on top</returns>
        private bool SetActorOnCollisionTile(Sprite s, Point mytile, float xCentre, float verticalOffset, float depthTolerance, List<int> passableTiles)
        {
            float dist = s.Bottom + verticalOffset - PixelLocationTop(mytile);
            if (s.MovedDown && dist < depthTolerance)
            {
                //check for tile above to make sure it's not a wall
                int tileabove = GetCollision(Location(mytile, TileMap.UP, 1));
                if (passableTiles.Contains(tileabove))
                {
                    SetActorAtTop(s, xCentre, mytile);
                    s.Velocity.Y = 0;
                    return true;
                }
            }
            return false;
        }

        /// <summary>
        /// places a sprites y position at the specific tile centre location
        /// the alignment of the sprite needs to be taken into account
        /// </summary>
        /// <param name="s">the sprite to position</param>
        /// <param name="tile">the tile to use for positioning</param>
        public void SetActorAtCentreY(Sprite s, Point tile)
        {
            s.Position.Y = tile.Y * tileHeight - RenderProperties.Displacement.Y + tileHeight * 0.5f;
        }
        /// <summary>
        /// places a sprites x position at the specific tile centre location
        /// the alignment of the sprite needs to be taken into account
        /// </summary>
        /// <param name="s">the sprite to position</param>
        /// <param name="tile">the tile to use for positioning</param>
        public void SetActorAtCentreX(Sprite s, Point tile)
        {
            s.Position.X = tile.X * tileWidth - RenderProperties.Displacement.X + tileWidth * 0.5f;
        }
        /// <summary>
        /// places a sprite at the specific tile centre location
        /// the alignment of the sprite needs to be taken into account
        /// </summary>
        /// <param name="s">the sprite to position</param>
        /// <param name="tile">the tile to use for positioning</param>
        public void SetActorAtCentre(Sprite s, Point tile)
        {
            s.Position.X = tile.X * tileWidth - RenderProperties.Displacement.X + tileWidth * 0.5f;
            s.Position.Y = tile.Y * tileHeight - RenderProperties.Displacement.Y + tileHeight * 0.5f;
        }
        /// <summary>
        /// sets an actor at the centre of its current tile. Useful for quick alignment
        /// </summary>
        /// <param name="s">the sprite to centre</param>
        public void SetActorAtCentre(Sprite s)
        {
            SetActorAtCentre(s, Location(s));
        }
        /// <summary>
        /// Determines if an actor is near the centre of a tile
        /// </summary>
        /// <param name="s">The sprite to check</param>
        /// <param name="tolerance">tolerance to apply</param>
        /// <returns>returns true if sprite is in centre of a tile and false if not</returns>
        public bool ActorAtCentre(Sprite s, float tolerance)
        {
            Vector2 p = PixelLocationTopLeft(Location(s.Centre2D.X, s.Centre2D.Y));
            //get centre
            p.X = p.X + tileWidth * 0.5f;
            p.Y = p.Y + tileHeight * 0.5f;

            return (Vector2.Distance(p, s.Centre2D) < tolerance);
        }


        /// <summary>
        /// Determines if an item actually exists in the tile map
        /// at the tile position given
        /// </summary>
        /// <param name="pos">The tile position to examine</param>
        /// <param name="item">an integer describing the tile type to search for</param>
        /// <returns>True if item exists, or false if doesn't exist or illegal tile position</returns>
        public bool ItemHereGraphic(Point pos, int item)
        {
            if (!WrapTileInterrogation)
            {
                if (pos.X < 0 || pos.X > Columns - 1) return false;
                if (pos.Y < 0 || pos.Y > Rows - 1) return false;
            }
            else
            {
                if (pos.X < 0) pos.X += Columns;
                else if (pos.X > Columns - 1) pos.X -= Columns;
                if (pos.Y < 0) pos.Y += Rows;
                else if (pos.Y > Rows - 1) pos.Y -= Rows;
            }
            
            //row major remember
            return dTiles[pos.Y, pos.X] == item;
        }

        /// <summary>
        /// Determines if an item within the specified list actually exists
        /// in the tilemap at the tile position given
        /// </summary>
        /// <param name="pos">The tile position to examine</param>
        /// <param name="items">a list of integers describing the tile types to search for</param>
        /// <returns>True if one exist or false if not</returns>
        public bool ItemHereGraphic(Point pos, int[] items)
        {
            if (!WrapTileInterrogation)
            {
                if (pos.X < 0 || pos.X > Columns - 1) return false;
                if (pos.Y < 0 || pos.Y > Rows - 1) return false;
            }
            else
            {
                if (pos.X < 0) pos.X += Columns;
                else if (pos.X > Columns - 1) pos.X -= Columns;
                if (pos.Y < 0) pos.Y += Rows;
                else if (pos.Y > Rows - 1) pos.Y -= Rows;
            }
            bool result = false;
            for (int i = 0; i < items.Length; i++)
                result = result || (dTiles[pos.Y, pos.X] == items[i]);
            return result;
        }

        /// <summary>
        /// determines if tile locations outside of manual tilemaps are wrapped (default is False)
        /// if true then tunnels can be implemented as locations past left will be wrapped to right of tilemap
        /// and the same for top and bottom
        /// </summary>
        public bool WrapTileInterrogation = false;
        /// <summary>
        /// holds an internal reference to the engine manager so we can acccess the engine directly for special tasks
        /// </summary>
        internal EngineManager engineManager;
        /// <summary>
        /// if true then when tilemap is added to the tilemap manager the
        /// autotileTexture will be tiled at 0,0
        /// </summary>
        internal bool autotile = false;
        /// <summary>
        /// texture for the tilemap manager to auto tile
        /// </summary>
        internal Image /*Texture2D*/ autotileTexture;

        /// <summary>
        /// Determines if an item within the specified list actually exists
        /// in the collision map at the tile position given
        /// </summary>
        /// <param name="pos">The tile position to examine</param>
        /// <param name="items">a list of integers describing the tile types to search for</param>
        /// <returns>True if one exist or false if not</returns>
        public bool ItemHereCollision(Point pos, int[] items)
        {
            if (!WrapTileInterrogation)
            {
                if (pos.X < 0 || pos.X > Columns - 1) return false;
                if (pos.Y < 0 || pos.Y > Rows - 1) return false;
            }
            else
            {
                if (pos.X < 0) pos.X += Columns;
                else if (pos.X > Columns - 1) pos.X -= Columns;
                if (pos.Y < 0) pos.Y += Rows;
                else if (pos.Y > Rows - 1) pos.Y -= Rows;
            }

            bool result = false;
            for (int i = 0; i < items.Length; i++)
                result = result || (cTiles[pos.Y, pos.X] == items[i]);
            return result;
        }
        /// <summary>
        /// Determines if an item actually exists in the collision map
        /// at the tile position given
        /// </summary>
        /// <param name="pos">The tile position to examine</param>
        /// <param name="item">an integer describing the tile types to search for</param>
        /// <returns>True if one exist or false if not</returns>
        public bool ItemHereCollision(Point pos, int item)
        {
            if (!WrapTileInterrogation)
            {
                if (pos.X < 0 || pos.X > Columns - 1) return false;
                if (pos.Y < 0 || pos.Y > Rows - 1) return false;
            }
            else
            {
                if (pos.X < 0) pos.X += Columns;
                else if (pos.X > Columns - 1) pos.X -= Columns;
                if (pos.Y < 0) pos.Y += Rows;
                else if (pos.Y > Rows - 1) pos.Y -= Rows;
            }

            return cTiles[pos.Y, pos.X] == item;
        }

        /// <summary>
        /// Centres map inside given area
        /// </summary>
        /// <param name="left">the left hand side of the area</param>
        /// <param name="top">The top of the area</param>
        /// <param name="width">the width of the area to centre within</param>
        /// <param name="height">The height of the area to centre within</param>
        public void CentreTileMap(float left, float top, float width, float height)
        {
            if (RenderProperties.CreateMatrix)
            {
                float actualW = Width * RenderProperties._scaleFactor;
                float actualH = Height * RenderProperties._scaleFactor;
                RenderProperties.Displacement.X = -((left + (width - actualW) * 0.5f) / RenderProperties._scaleFactor);
                RenderProperties.Displacement.Y = -((top + (height - actualH) * 0.5f) / RenderProperties._scaleFactor);
            }
            else
            {
                RenderProperties.Displacement.X = -(left + (width - Width) * 0.5f);
                RenderProperties.Displacement.Y = -(top + (height - Height) * 0.5f);
            }
        }
        /// <summary>
        /// Centres map inside given rectangle area
        /// </summary>
        /// <param name="area">The rectangle that we want to centre inside of</param>
        public void CentreTileMap(Rectangle area)
        {
            //call central method with split parameters
            CentreTileMap(area.Left, area.Top, area.Width, area.Height);
        }

        /// <summary>
        /// Centres the tilemap vertically
        /// </summary>
        /// <param name="top">The top of the area</param>
        /// <param name="height">The height of the area to centre within</param>
        public void CentreTileMapY(float top, float height)
        {
            if (RenderProperties.CreateMatrix)
            {
                float actualH = Height * RenderProperties._scaleFactor;
                RenderProperties.Displacement.Y = -((top + (height - actualH) * 0.5f) / RenderProperties._scaleFactor);
            }
            else
            {
                RenderProperties.Displacement.Y = -(top + (height - Height) * 0.5f);
            }
        }
        /// <summary>
        /// Centres map horizontally inside given area
        /// </summary>
        /// <param name="area">Rectangluar area to centre within</param>
        public void CentreTileMapY(Rectangle area)
        {
            //call central method with split parameters
            CentreTileMapX(area.Left, area.Width);
        }
        /// <summary>
        /// Centres map horizontally inside given area
        /// </summary>
        /// <param name="left">the left hand side of the area</param>
        /// <param name="width">the width of the area to centre within</param>
        public void CentreTileMapX(float left, float width)
        {
            if (RenderProperties.CreateMatrix)
            {
                float actualW = Width * RenderProperties._scaleFactor;
                RenderProperties.Displacement.X = -((left + (width - actualW) * 0.5f) / RenderProperties._scaleFactor);
            }
            else
            {
                RenderProperties.Displacement.X = -(left + (width - Width) * 0.5f);
            }
        }
        /// <summary>
        /// Horizontally centres the tilemap
        /// </summary>
        /// <param name="area">Rectangluar area to centre within</param>
        public void CentreTileMapX(Rectangle area)
        {
            //call central method with split parameters
            CentreTileMapX(area.Left, area.Width);
        }

        /// <summary>
        /// Converts existing tileMap into a collision map
        /// You can use CollisionMap to set directly your own map but this must be the same size 
        /// as your tilemap
        /// </summary>
        /// <param name="collisionBlocks">A list of collision tiles which map the display tiles to specific collision ones, 
        /// make sure this has enough entries to cover all the display tiles</param>
        public void CreateCollisionMap(int[] collisionBlocks/*int width, int height*/)
        {
            int row = 0;
            int col = 0;
            try
            {
                cTiles = new int[Rows, Columns];
                for (row = 0; row < Rows; row++)
                {
                    for (col = 0; col < Columns; col++)
                    {
                        if (dTiles[row,col] != -1)
                            cTiles[row, col] = collisionBlocks[dTiles[row, col]];
                    }
                }
            }
            catch
            {
                Point p = new Point(row, col);
                throw new ArgumentException(
                        "collision block does not contain an element for\n" +
                        "display tile number " + dTiles[row,col].ToString() + "\n" +
                        "at position (Row, Col)" + p.ToString());
            }
        }//create collision map

        /// <summary>
        /// Checks to see if a proposed move is legal from current tile in direction propsed
        /// checks against tile map
        /// </summary>
        /// <param name="currentTile">tile location</param>
        /// <param name="direction">direction to check 0 - left, 1, right, 2 up 3 down</param>
        /// <param name="illegal">array of illegal tiles</param>
        /// <returns>true if propsed move is legal</returns>
        public bool LegalMoveGraphic(Point currentTile, int direction, int[] illegal)
        {
            //return Contains(TileValidDirections(currentTile, illegal), direction);
            return ValidDirectionsGraphic(currentTile, illegal).Contains(direction);
        }
        /// <summary>
        /// Checks to see if a proposed move is legal from current tile in direction propsed
        /// checks against collision map
        /// </summary>
        /// <param name="currentTile">tile location</param>
        /// <param name="direction">direction to check 0 - left, 1, right, 2 up 3 down</param>
        /// <param name="illegal">array of illegal tiles</param>
        /// <returns>true if propsed move is legal</returns>
        public bool LegalMoveCollision(Point currentTile, int direction, int[] illegal)
        {
            return ValidDirectionsCollision(currentTile, illegal).Contains( direction);
        }
        /// <summary>
        /// Indentifies the immediate directions a particular set of tiles are available from the collision map
        /// </summary>
        /// <param name="pos">The starting tile</param>
        /// <param name="search">Item array to look for</param>
        /// <returns>list of ordinals to target</returns>
        public List<int> DirectionsCollision(Point pos, int[] search)
        {
            List<int> validList = new List<int>();
            if (ItemHereCollision(Location(pos, LEFT, 1), search))
                validList.Add(LEFT);
            if (ItemHereCollision(Location(pos, RIGHT, 1), search))
                validList.Add(RIGHT);
            if (ItemHereCollision(Location(pos, UP, 1), search))
                validList.Add(UP);
            if (ItemHereCollision(Location(pos, DOWN, 1), search))
                validList.Add(DOWN);
            if (MinorOrdinals)
            {
                if (ItemHereCollision(Location(pos, UP_LEFT, 1), search))
                    validList.Add(UP_LEFT);
                if (ItemHereCollision(Location(pos, UP_RIGHT, 1), search))
                    validList.Add(UP_RIGHT);
                if (ItemHereCollision(Location(pos, DOWN_LEFT, 1), search))
                    validList.Add(DOWN_LEFT);
                if (ItemHereCollision(Location(pos, DOWN_RIGHT, 1), search))
                    validList.Add(DOWN_RIGHT);
            }
            return validList;
        }

        /// <summary>
        /// Checks the collision map for available positions from given tile
        /// </summary>
        /// <param name="pos">The position to look for valid directions from</param>
        /// <param name="illegal">A list of the tiles that cannot be moved onto</param>
        /// <returns>a list of valid directions</returns>
        public List<int> ValidDirectionsCollision(Point pos, int[] illegal)
        {
            List<int> validList = new List<int>();
            if (!ItemHereCollision(Location(pos, LEFT, 1), illegal))
                validList.Add(LEFT);
            if (!ItemHereCollision(Location(pos, RIGHT, 1), illegal))
                validList.Add(RIGHT);
            if (!ItemHereCollision(Location(pos, UP, 1), illegal))
                validList.Add(UP);
            if (!ItemHereCollision(Location(pos, DOWN, 1), illegal))
                validList.Add(DOWN);
            if (MinorOrdinals)
            {
                if (!ItemHereCollision(Location(pos, UP_LEFT, 1), illegal))
                    validList.Add(UP_LEFT);
                if (!ItemHereCollision(Location(pos, UP_RIGHT, 1), illegal))
                    validList.Add(UP_RIGHT);
                if (!ItemHereCollision(Location(pos, DOWN_LEFT, 1), illegal))
                    validList.Add(DOWN_LEFT);
                if (!ItemHereCollision(Location(pos, DOWN_RIGHT, 1), illegal))
                    validList.Add(DOWN_RIGHT);
            }

            return validList;
        }
        /// <summary>
        /// Checks the collision map for available positions from given tile, given a legal list of tiles to occupy
        /// </summary>
        /// <param name="pos">The position to look for valid directions from</param>
        /// <param name="legal">A list of the tiles that can be moved onto</param>
        /// <returns>a list of valid directions</returns>
        public List<int> ValidDirectionsLegalListCollision(Point pos, int[] legal)
        {
            List<int> validList = new List<int>();
            if (ItemHereCollision(Location(pos, LEFT, 1), legal))
                validList.Add(LEFT);
            if (ItemHereCollision(Location(pos, RIGHT, 1), legal))
                validList.Add(RIGHT);
            if (ItemHereCollision(Location(pos, UP, 1), legal))
                validList.Add(UP);
            if (ItemHereCollision(Location(pos, DOWN, 1), legal))
                validList.Add(DOWN);
            if (MinorOrdinals)
            {
                if (ItemHereCollision(Location(pos, UP_LEFT, 1), legal))
                    validList.Add(UP_LEFT);
                if (ItemHereCollision(Location(pos, UP_RIGHT, 1), legal))
                    validList.Add(UP_RIGHT);
                if (ItemHereCollision(Location(pos, DOWN_LEFT, 1), legal))
                    validList.Add(DOWN_LEFT);
                if (ItemHereCollision(Location(pos, DOWN_RIGHT, 1), legal))
                    validList.Add(DOWN_RIGHT);
            }
            return validList;
        }
        /// <summary>
        /// removes any directions that move outside of tile space
        /// </summary>
        /// <param name="currentPosition">current tile location</param>
        /// <param name="possibleDirections">directions to test</param>
        /// <param name="distance">number of tiles to move</param>
        public void RemoveDirectionsOutOfBounds(Point currentPosition, ref List<int> possibleDirections, int distance)
        {
            for (int i = possibleDirections.Count -1; i >= 0; i--)
            {
                if (!ValidTile(Location(currentPosition, possibleDirections[i], distance)))
                    possibleDirections.RemoveAt(i);
            }
        }
        /// <summary>
        /// removes any directions that move outside of tile space in one direction
        /// </summary>
        /// <param name="currentPosition">current tile location</param>
        /// <param name="possibleDirections">directions to test</param>
        public void RemoveDirectionsOutOfBounds(Point currentPosition, ref List<int> possibleDirections)
        {
            for (int i = possibleDirections.Count - 1; i >= 0; i--)
            {
                if (!ValidTile(Location(currentPosition, possibleDirections[i], 1)))
                    possibleDirections.RemoveAt(i);
            }
        }
        /// <summary>
        /// Checks the tile map for availble positions from given tile, given a set of illegal tiles
        /// </summary>
        /// <param name="pos">The position to look for valid directions from</param>
        /// <param name="illegal">A list of the tiles that cannot be moved onto</param>
        /// <returns>a list of valid directions</returns>
        public List<int> ValidDirectionsGraphic(Point pos, int[] illegal)
        {
            List<int> validList = new List<int>();
            if (!ItemHereGraphic(Location(pos, LEFT, 1), illegal))
                validList.Add(LEFT);
            if (!ItemHereGraphic(Location(pos, RIGHT, 1), illegal))
                validList.Add(RIGHT);
            if (!ItemHereGraphic(Location(pos, UP, 1), illegal))
                validList.Add(UP);
            if (!ItemHereGraphic(Location(pos, DOWN, 1), illegal))
                validList.Add(DOWN);
            if (MinorOrdinals)
            {
                if (!ItemHereGraphic(Location(pos, UP_LEFT, 1), illegal))
                    validList.Add(UP_LEFT);
                if (!ItemHereGraphic(Location(pos, UP_RIGHT, 1), illegal))
                    validList.Add(UP_RIGHT);
                if (!ItemHereGraphic(Location(pos, DOWN_LEFT, 1), illegal))
                    validList.Add(DOWN_LEFT);
                if (!ItemHereGraphic(Location(pos, DOWN_RIGHT, 1), illegal))
                    validList.Add(DOWN_RIGHT);
            }

            return validList;
        }
        /// <summary>
        /// Checks the tile map for availble positions from given tile, given a set of legal tiles
        /// </summary>
        /// <param name="pos">The position to look for valid directions from</param>
        /// <param name="legal">A list of the tiles that can be moved onto</param>
        /// <returns>a list of valid directions</returns>
        public List<int> ValidDirectionsLegalListGraphic(Point pos, int[] legal)
        {
            List<int> validList = new List<int>();
            if (ItemHereGraphic(Location(pos, LEFT, 1), legal))
                validList.Add(LEFT);
            if (ItemHereGraphic(Location(pos, RIGHT, 1), legal))
                validList.Add(RIGHT);
            if (ItemHereGraphic(Location(pos, UP, 1), legal))
                validList.Add(UP);
            if (ItemHereGraphic(Location(pos, DOWN, 1), legal))
                validList.Add(DOWN);
            if (MinorOrdinals)
            {
                if (ItemHereGraphic(Location(pos, UP_LEFT, 1), legal))
                    validList.Add(UP_LEFT);
                if (ItemHereGraphic(Location(pos, UP_RIGHT, 1), legal))
                    validList.Add(UP_RIGHT);
                if (ItemHereGraphic(Location(pos, DOWN_LEFT, 1), legal))
                    validList.Add(DOWN_LEFT);
                if (ItemHereGraphic(Location(pos, DOWN_RIGHT, 1), legal))
                    validList.Add(DOWN_RIGHT);
            }
            return validList;
        }

        /// <summary>
        /// Gets the opposite direction a sprite is moving int terms of TileMap ordinal directions
        /// only to be used for sprites moving in ordinal tile maps
        /// </summary>
        /// <param name="me">The sprite to observe</param>
        /// <returns>TileMap.Left or TileMap.Right or TileMap.Down or TileMap.UP or TileMap.NONE if not moving</returns>
        public static int OppositeOrdinalDirection(Sprite me)
        {
            if (me.Velocity.X < 0) return RIGHT;
            if (me.Velocity.X > 0) return LEFT;
            if (me.Velocity.Y < 0) return DOWN;
            if (me.Velocity.Y > 0) return UP;
            return NONE;
        }

        /// <summary>
        /// Gets the opposite direction a velocity is moving int terms of TileMap ordinal directions
        /// only to be used for velocities  in ordinal tile maps
        /// </summary>
        /// <param name="velocity">The velocity to examine</param>
        /// <returns>TileMap.Left or TileMap.Right or TileMap.Down or TileMap.UP or TileMap.NONE if not moving</returns>
        public static int OppositeOrdinalDirection(Vector3 velocity)
        {
            if (velocity.X < 0) return RIGHT;
            if (velocity.X > 0) return LEFT;
            if (velocity.Y < 0) return DOWN;
            if (velocity.Y > 0) return UP;
            return NONE;
        }

        /// <summary>
        /// returns the opposite ordinal direction of the given direction (TILEMAP.LEFT, ..RIGHT, ..UP, ..DOWN)
        /// </summary>
        /// <param name="direction">Direction to determine opposite of</param>
        /// <returns>Opposite of given direction</returns>
        public static int OppositeOrdinalDirection(int direction)
        {
            switch (direction)
            {
                case LEFT: return RIGHT;
                case RIGHT: return LEFT;
                case UP: return DOWN;
                case DOWN: return UP;
                case UP_LEFT: return DOWN_RIGHT;
                case UP_RIGHT: return DOWN_LEFT;
                case DOWN_LEFT: return UP_RIGHT;
                case DOWN_RIGHT: return UP_LEFT;
            }
            return NONE;
        }

        /// <summary>
        /// determines if the sprite is in collision with a tile, does not check centre of sprite 
        /// </summary>
        /// <param name="me">sprite to check for collision with</param>
        /// <param name="tileList">List of tile indexes to check against</param>
        /// <returns>A list of points or an empty list if no collisions</returns>
        public List<Point> CollisionGraphic(Sprite me, int[] tileList)
        {
            List<Point> collidedWith = new List<Point>();
            Point p;
            //check to the left
            p = Location(me.Left, me.Centre2D.Y);
            if (ItemHereGraphic(p, tileList))
                collidedWith.Add(p);

            //check to the right
            p = Location(me.Right, me.Centre2D.Y);
            if (ItemHereGraphic(p, tileList))
                collidedWith.Add(p);

            //check to the Top
            p = Location(me.Centre2D.X, me.Top);
            if (ItemHereGraphic(p, tileList))
                collidedWith.Add(p);

            //check to the bottom
            p = Location(me.Centre2D.X, me.Bottom);
            if (ItemHereGraphic(p, tileList))
                collidedWith.Add(p);
            //if (MinorOrdinals)
            //{
            //    //check to the left
            //    p = Location(me.Left, me.Top);
            //    if (ItemHereGraphic(p, tileList))
            //        collidedWith.Add(p);

            //    //check to the right
            //    p = Location(me.Right, me.Centre2D.Y);
            //    if (ItemHereGraphic(p, tileList))
            //        collidedWith.Add(p);

            //    //check to the Top
            //    p = Location(me.Centre2D.X, me.Top);
            //    if (ItemHereGraphic(p, tileList))
            //        collidedWith.Add(p);

            //    //check to the bottom
            //    p = Location(me.Centre2D.X, me.Bottom);
            //    if (ItemHereGraphic(p, tileList))
            //        collidedWith.Add(p);
            //}
            return collidedWith;
        }
        /// <summary>
        /// determines if the sprite is in collision with a tile, does not check centre of sprite 
        /// will align sprite so it is touching the edge of the tile + an offset
        /// </summary>
        /// <param name="me">sprite to check for collision with</param>
        /// <param name="tileList">List of tile indexes to check against</param>
        /// <param name="offset">A pixel amount to apply to the adjusted sprite position</param>
        /// <returns>A list of points or an empty list if no collisions</returns>
        public List<Point> CollisionAlignGraphic(Sprite me, int[] tileList, float offset)
        {
            List<Point> collidedWith = new List<Point>();

            Point p;
            //check to the left
            p = Location(me.Left, me.Centre2D.Y);
            if (ItemHereGraphic(p, tileList))
            {
                SpriteHelper.AlignLeftAt(me, PixelLocationLeft(p) + tileWidth + offset);
                collidedWith.Add(p);
            }
            //check to the right
            p = Location(me.Right, me.Centre2D.Y);
            if (ItemHereGraphic(p, tileList))
            {
                SpriteHelper.AlignRightAt(me, PixelLocationLeft(p) - offset);
                collidedWith.Add(p);
            }
            //check to the Top
            p = Location(me.Centre2D.X, me.Top);
            if (ItemHereGraphic(p, tileList))
            {
                SpriteHelper.AlignTopAt(me, PixelLocationTop(p) + tileHeight + offset);
                collidedWith.Add(p);
            }
            //check to the left
            p = Location(me.Centre2D.X, me.Bottom);
            if (ItemHereGraphic(p, tileList))
            {
                SpriteHelper.AlignBottomAt(me, PixelLocationTop(p) - offset);
                collidedWith.Add(p);
            }
            return collidedWith;

        }
        /// <summary>
        /// determines if there is a clear path between the position A to position B without encountering any specific collision tiles
        /// only the tiles specified in the tilelist are including in the line of sight test.
        /// if a tile blocks the sight then its position is returned
        /// </summary>
        /// <param name="A">the first tile location</param>
        /// <param name="B">the second location to cast a ray to</param>
        /// <param name="stepratio">0.2f is a good starter value here, percentage of tile width to move along ray to determine collision with tile 1, will step the width and height of a tile 0.5f will step half the width, the smaller the number the more accurate but slower collision checks will be </param>
        /// <param name="tileList">List of tile indexes to check against</param>
        /// <returns>a the index</returns>
        public Point LineOfSiteCollision(Vector2 A, Vector2 B, float stepratio, int[] tileList)
        {
            //get hold of a list of tiles along this path
            List<Point> pl = LocationsBetween(A, B, stepratio);
            return InListCollision(pl, tileList);
        }
        /// <summary>
        /// Checks a list of tile locations to see of a given collision tile exists, returning the first occurance 
        /// </summary>
        /// <param name="tileLocations">a list of tile locations to check</param>
        /// <param name="tileList">collision tiles to check existence of</param>
        /// <returns>the tile location of the first wanted collision tile, or -1,-1 if non exist</returns>
        public Point InListCollision(List<Point> tileLocations, int[] tileList)
        {
            int i = 0;
            while (i < tileLocations.Count)
            {
                if (ItemHereCollision(tileLocations[i], tileList))
                    return tileLocations[i];
                i++;
            }
            //no collision
            return new Point(-1, -1);
        }

        /// <summary>
        /// Generates a list of tiles between two points given a ratio of accuracy
        /// </summary>
        /// <param name="A">start point</param>
        /// <param name="B">end point</param>
        /// <param name="stepratio">0.2f is a good starter value here, percentage of tile width to move along ray to determine collision with tile 1, will step the width and height of a tile 0.5f will step half the width, the smaller the number the more accurate but slower collision checks will be </param>
        /// <returns>the list of tile locations between the 2 points</returns>
        public List<Point> LocationsBetween(Vector2 A, Vector2 B, float stepratio)
        {
            Point location = new Point(-1, -1);
            List<Point> tileLocations = new List<Point>();

            //get start tile
            tileLocations.Add(Location(A.X, A.Y));

            //get direction vector 
            Vector2 grad = B - A;
            float distance = grad.Length();

            grad.Normalize();
            //set step ratio
            grad.X *= (tileWidth * stepratio);
            grad.Y *= (TileHeight * stepratio);
            float steplength = grad.Length();

            int steps = (int)(distance / steplength);
            float xp = A.X;
            float yp = A.Y;
            int i = 0;
            //get tile locations
            while (i < steps)
            {
                //step along line
                xp += grad.X;
                yp += grad.Y;

                //get tile location for this current position
                location = Location(xp, yp);
                //add to tile list if not just added or haven't ad
                if (tileLocations[tileLocations.Count - 1] != location)
                    tileLocations.Add(location);
                i++;
            }
            //do we need to add last location tile?
            //this could not get included if accuracy not good
            location = Location(B.X, B.Y);
            if (tileLocations[tileLocations.Count - 1] != location)
                tileLocations.Add(location);
            //need to produce a list of intersecting tiles
            return tileLocations;
        }

        /// <summary>
        /// determines if there is a clear path between the position A to position B without encountering any specific graphic tiles
        /// only the tiles specified in the tilelist are including in the line of sight test.
        /// if a tile blocks the sight then its position is returned
        /// </summary>
        /// <param name="A">the first tile location</param>
        /// <param name="B">the second location to cast a ray to</param>
        /// <param name="stepratio">0.2f is a good starter value here, percentage of tile width to move along ray to determine collision with tile 1, will step the width and height of a tile 0.5f will step half the width, the smaller the number the more accurate but slower collision checks will be </param>
        /// <param name="tileList">List of tile indexes to check against</param>
        /// <returns>a point with negative values if no tile is blocking, otherwise the tile location where collision did occur</returns>
        public Point LineOfSiteGraphic(Vector2 A, Vector2 B, float stepratio, int[] tileList)
        {
            //get hold of a list of tiles along this path
            List<Point> pl = LocationsBetween(A, B, stepratio);
            return InListGraphic(pl, tileList);
        }
        /// <summary>
        /// Checks a list of tile locations to see of a given tile exists. 
        /// </summary>
        /// <param name="tileLocations">a list of tile locations to check</param>
        /// <param name="tileList">tiles to check existence of</param>
        /// <returns>the tile location of the first wanted tile, or -1,-1 if non exist</returns>
        public Point InListGraphic(List<Point> tileLocations, int[] tileList)
        {
            int i = 0;
            while (i < tileLocations.Count)
            {
                if (ItemHereGraphic(tileLocations[i], tileList))
                    return tileLocations[i];
                i++;
            }
            //no collision
            return new Point(-1, -1);
        }

        /// <summary>
        /// determines if the sprite is in collision with a collision tile, does not check centre of sprite 
        /// </summary>
        /// <param name="me">sprite to check for collision with</param>
        /// <param name="tileList">List of tile indexes to check against</param>
        /// <returns>A list of points or an empty list if no collisions</returns>
        public List<Point> CollisionCollision(Sprite me, int[] tileList)
        {
            List<Point> collidedWith = new List<Point>();
            Point p;
            //check to the left
            p = Location(me.Left, me.Centre2D.Y);
            if (ItemHereCollision(p, tileList))
                collidedWith.Add(p);

            //check to the right
            p = Location(me.Right, me.Centre2D.Y);
            if (ItemHereCollision(p, tileList))
                collidedWith.Add(p);

            //check to the Top
            p = Location(me.Centre2D.X, me.Top);
            if (ItemHereCollision(p, tileList))
                collidedWith.Add(p);

            //check to the bottom
            p = Location(me.Centre2D.X, me.Bottom);
            if (ItemHereCollision(p, tileList))
                collidedWith.Add(p);

            return collidedWith;
        }
        /// <summary>
        /// determines if the sprite is in collision with a collision tile, does not check centre of sprite 
        /// </summary>
        /// <param name="me">sprite to check for collision with</param>
        /// <param name="tileList">List of tile indexes to check against</param>
        /// <param name="pad">An amount ot add to sprites boundaries before checking for collision</param>
        /// <returns>A list of points or an empty list if no collisions</returns>
        public List<Point> CollisionCollision(Sprite me, int[] tileList, float pad)
        {
            List<Point> collidedWith = new List<Point>();
            Point p;
            //check to the left
            p = Location(me.Left, me.Centre2D.Y);
            if (ItemHereCollision(p, tileList))
                collidedWith.Add(p);

            //check to the right
            p = Location(me.Right, me.Centre2D.Y);
            if (ItemHereCollision(p, tileList))
                collidedWith.Add(p);

            //check to the Top
            p = Location(me.Centre2D.X, me.Top);
            if (ItemHereCollision(p, tileList))
                collidedWith.Add(p);

            //check to the bottom
            p = Location(me.Centre2D.X, me.Bottom);
            if (ItemHereCollision(p, tileList))
                collidedWith.Add(p);

            return collidedWith;
        }
        /// <summary>
        /// determines if the sprite is in collision with a collision tile, does not check centre of sprite 
        /// will align sprite so it is touching the edge of the tile + an offset
        /// </summary>
        /// <param name="me">sprite to check for collision with</param>
        /// <param name="tileList">List of tile indexes to check against</param>
        /// <param name="offset">A pixel amount to apply to the adjusted sprite position</param>
        /// <returns>A list of points or an empty list if no collisions</returns>
        public List<Point> CollisionAlignCollision(Sprite me, int[] tileList, float offset)
        {
            List<Point> collidedWith = new List<Point>();

            Point p;
            //check to the left
            p = Location(me.Left, me.Centre2D.Y);
            if (ItemHereCollision(p, tileList))
            {
                SpriteHelper.AlignLeftAt(me, PixelLocationLeft(p) + tileWidth + offset);
                collidedWith.Add(p);
            }
            //check to the right
            p = Location(me.Right, me.Centre2D.Y);
            if (ItemHereCollision(p, tileList))
            {
                SpriteHelper.AlignRightAt(me, PixelLocationLeft(p) - offset);
                collidedWith.Add(p);
            }
            //check to the Top
            p = Location(me.Centre2D.X, me.Top);
            if (ItemHereCollision(p, tileList))
            {
                SpriteHelper.AlignTopAt(me, PixelLocationTop(p) + tileHeight + offset);
                collidedWith.Add(p);
            }
            //check to the left
            p = Location(me.Centre2D.X, me.Bottom);
            if (ItemHereCollision(p, tileList))
            {
                SpriteHelper.AlignBottomAt(me, PixelLocationTop(p) - offset);
                collidedWith.Add(p);
            }
            return collidedWith;

        }

        /// <summary>
        /// determines if the sprite is in collision with a collision tile, does not check centre of sprite 
        /// will align sprite so it is touching the edge of the tile + an offset
        /// </summary>
        /// <param name="me">sprite to check for collision with</param>
        /// <param name="tileList">List of tile indexes to check against</param>
        /// <param name="offset">A pixel amount to apply to the adjusted sprite position</param>
        /// <param name="pad">An overlap to apply to sprite position before testing</param>
        /// <returns>A list of points or an empty list if no collisions</returns>
        public List<Point> CollisionAlignCollision(Sprite me, int[] tileList, float offset, float pad)
        {
            List<Point> collidedWith = new List<Point>();

            Point p;
            //check to the left
            p = Location(me.Left - pad, me.Centre2D.Y);
            if (ItemHereCollision(p, tileList))
            {
                SpriteHelper.AlignLeftAt(me, PixelLocationLeft(p) + tileWidth + offset);
                collidedWith.Add(p);
            }
            //check to the right
            p = Location(me.Right + pad, me.Centre2D.Y);
            if (ItemHereCollision(p, tileList))
            {
                SpriteHelper.AlignRightAt(me, PixelLocationLeft(p) - offset);
                collidedWith.Add(p);
            }
            //check to the Top
            p = Location(me.Centre2D.X, me.Top - pad);
            if (ItemHereCollision(p, tileList))
            {
                SpriteHelper.AlignTopAt(me, PixelLocationTop(p) + tileHeight + offset);
                collidedWith.Add(p);
            }
            //check to the left
            p = Location(me.Centre2D.X, me.Bottom + pad);
            if (ItemHereCollision(p, tileList))
            {
                SpriteHelper.AlignBottomAt(me, PixelLocationTop(p) - offset);
                collidedWith.Add(p);
            }
            return collidedWith;

        }

        /// <summary>
        /// Determines the general direction of the centre of a sprite to the tile given
        /// used for collision work (reflection)
        /// </summary>
        /// <param name="me">Sprite to compare with tile</param>
        /// <param name="to">tile to look towards</param>
        /// <returns>TileMap.Left or TileMap.Right or TileMap.Down or TileMap.UP or TileMap.NONE if not moving</returns>
        public int GetOrdinalDirectionTo(Sprite me, Point to)
        {
            return GetOrdinalDirectionTo(Location(me), to);
        }
        /// <summary>
        /// Determines the general direction of one tile to the tile given
        /// </summary>
        /// <param name="from">tile to look from</param>
        /// <param name="to">tile to look towards</param>
        /// <returns>TileMap.Left or TileMap.Right or TileMap.Down or TileMap.UP or TileMap.NONE if not moving</returns>
        public static int GetOrdinalDirectionTo(Point from, Point to)
        {
            int dx = from.X - to.X;
            int dy = from.Y - to.Y;


            return (((dx > 0) ? dx : -dx) >= ((dy > 0 )? dy : -dy)) ? dx > 0 ? LEFT : RIGHT : dy > 0 ? UP : DOWN;
            
        }

        /// <summary>
        /// Gets the direction a sprite is moving int terms of TileMap ordinal directions
        /// only to be used for sprites moving in ordinal tile maps e.g only one direction no diagonals
        /// </summary>
        /// <param name="me">The sprite to observe</param>
        /// <returns>TileMap.Left or TileMap.Right or TileMap.Down or TileMap.UP or TileMap.NONE if not moving</returns>
        public static int GetOrdinalDirection(Sprite me)
        {
            //edit to convert ordinal before attempting to 
            Vector3 ord = RotationHelper.Ordinalise(me.Velocity);
            if (ord.X < 0) return LEFT;
            if (ord.X > 0) return RIGHT;
            if (ord.Y < 0) return UP;
            if (ord.Y > 0) return DOWN;
            return NONE;

            //if (me.Velocity.X < 0) return LEFT;
            //if (me.Velocity.X > 0) return RIGHT;
            //if (me.Velocity.Y < 0) return UP;
            //if (me.Velocity.Y > 0) return DOWN;
            //return NONE;
        }
        /// <summary>
        /// Gets the direction a velocity or direction vector and ordinalises it (determines which north, south, east or west is most similar)
        /// returning direction in terms of TileMap ordinal directions
        /// only to be used for velocities  in ordinal tile maps
        /// </summary>
        /// <param name="velocity">The velocity to examine</param>
        /// <returns>TileMap.Left or TileMap.Right or TileMap.Down or TileMap.UP or TileMap.NONE if not moving</returns>
        public static int GetOrdinalDirection(Vector3 velocity)
        {
            velocity = RotationHelper.Ordinalise(velocity);
            if (velocity.X < 0) return LEFT;
            if (velocity.X > 0) return RIGHT;
            if (velocity.Y < 0) return UP;
            if (velocity.Y > 0) return DOWN;
            return NONE;
        }
        /// <summary>
        /// Gets the direction vector and ordinalises it (determines which north, south, east or west is most similar)
        /// returning direction in terms of TileMap ordinal directions
        /// only to be used for velocities  in ordinal tile maps
        /// </summary>
        /// <param name="direction">The 2d direction vector to examine</param>
        /// <returns>TileMap.Left or TileMap.Right or TileMap.Down or TileMap.UP or TileMap.NONE if not moving</returns>
        public static int GetOrdinalDirection(Vector2 direction) {
            direction = RotationHelper.Ordinalise(direction);
            if (direction.X < 0) return LEFT;
            if (direction.X > 0) return RIGHT;
            if (direction.Y < 0) return UP;
            if (direction.Y > 0) return DOWN;
            return NONE;
        }
        /// <summary>
        /// Attempts to remove the opposite direction that a sprite is moving in a list
        /// of possible directions. This stops actors from going back on themselves when
        /// making decisions at junctions (not a very desirable trait)
        /// </summary>
        /// <param name="possibleDirections">List of directions create with TileValidDirections (possibly)</param>
        /// <param name="me">The sprite that is moving and going to make a decision</param>
        public static void RemoveOppositeDirection(ref List<int> possibleDirections, Sprite me)
        {
            int opposite = GetOrdinalDirection(me.Velocity * -1);
            
            int i = 0;
            while (i < possibleDirections.Count)
            {
                if (opposite == possibleDirections[i])
                {
                    //remove if more than one item was in the list
                    if (possibleDirections.Count > 1)
                    {
                        possibleDirections.RemoveAt(i);
                        return;
                    }
                    i++;
                }
                else
                    i++;
            }
        }
        /// <summary>
        /// removes if possible the opposite direction to the one given from the list
        /// </summary>
        /// <param name="possibleDirections">a list of directions</param>
        /// <param name="direction">the direction which we want the opposite direction</param>
        public static void RemoveOppositeDirection(ref List<int> possibleDirections, int direction)
        {
            int opposite = OppositeOrdinalDirection(direction);

            int i = 0;
            while (i < possibleDirections.Count)
            {
                if (opposite == possibleDirections[i])
                {
                    //remove if more than one item was in the list
                    if (possibleDirections.Count > 1)
                    {
                        possibleDirections.RemoveAt(i);
                        return;
                    }
                    i++;
                }
                else
                    i++;
            }
        }

        /// <summary>
        /// Attempts to remove a given direction if it is in the given list
        /// of possible directions. This stops actors from taking certain routes from specific tiles
        /// in maps. if one direction only available then it will not be removed
        /// </summary>
        /// <param name="possibleDirections">List of directions create with TileValidDirections (possibly)</param>
        /// <param name="ordinalDirection">direction to attempt to remove</param>
        public static void RemoveDirection(ref List<int> possibleDirections, int ordinalDirection)
        {
            int i = 0;
            while (i < possibleDirections.Count)
            {
                if (ordinalDirection == possibleDirections[i])
                {
                    //remove if more than one item was in the list
                    if (possibleDirections.Count > 1)
                    {
                        possibleDirections.RemoveAt(i);
                        return;
                    }
                    i++;
                }
                else
                    i++;
            }
        }

        /// <summary>
        /// works out a displacement from a sprites centre tile in the direction it is moving
        /// </summary>
        /// <param name="displacement">number of tiles to look, uses negative numbers for behind</param>
        /// <param name="actor">The sprite to find the tile in front of</param>
        /// <returns>a tile displacement positions in front of the actor</returns>
        public Point LocationForward(Sprite actor, int displacement)
        {
            return Location(Location(actor), GetOrdinalDirection(actor), displacement);
        }
        /// <summary>
        /// works out the displacement from a tile in the direction given
        /// </summary>
        /// <param name="displacement">number of tiles to look, use negative numbers for behind</param>
        /// <param name="location">Tile to displace from</param>
        /// <param name="direction">direction to look</param>
        /// <returns>a tile location which is displaced as requested</returns>
        public Point LocationForward(Point location, Vector3 direction, int displacement)
        {
            return Location(location, GetOrdinalDirection(direction), displacement);
        }

        /// <summary>
        /// Attempts to determine which of a list of directions would give the shortest distance as the crow
        /// would fly (direct distance), returning the ordinal direction (TileMap.Left, TileMap.Right etc...)
        /// </summary>
        /// <param name="directions">a list of available directions to try</param>
        /// <param name="currentTile">The current tile to check distance from</param>
        /// <param name="targetTile">Tile checking distance to</param>
        /// <returns>ordinal number of direction with shortest distance (TileMap.Left, TileMap.Right etc...)</returns>
        public int ShortestDistanceCrow(List<int> directions, Point currentTile, Point targetTile)
        {
            //just return one direction if that was all available
            if (directions.Count == 1)
                return directions[0];

            Point workingTile = Point.Zero;
            float workingDistance = 0;
            float shortestDistance = float.MaxValue;
            int chosenDirection = TileMap.NONE;

            foreach (int ordinal in directions)
            {
                //should be possible to do this
                //workingTile = Location(currentTile, ordinal, 1);
                switch (ordinal)
                {
                    case LEFT: workingTile = Location(currentTile, LEFT, 1); break;
                    case RIGHT: workingTile = Location(currentTile, RIGHT, 1); break;
                    case UP: workingTile = Location(currentTile, UP, 1); break;
                    case DOWN: workingTile = Location(currentTile, DOWN, 1); break;
                    case UP_LEFT: workingTile = Location(currentTile, UP_LEFT, 1); break;
                    case UP_RIGHT: workingTile = Location(currentTile, UP_RIGHT, 1); break;
                    case DOWN_LEFT: workingTile = Location(currentTile, DOWN_LEFT, 1); break;
                    case DOWN_RIGHT: workingTile = Location(currentTile, DOWN_RIGHT, 1); break;
                }
                workingDistance = PointHelper.DistanceSquared(targetTile, workingTile);
                //distance = Vector2.DistanceSquared(targetPos, new Vector2(newTile.X, newTile.Y));
                if (workingDistance < shortestDistance)
                {
                    shortestDistance = workingDistance;
                    chosenDirection = ordinal;
                }//end switch
            }//end foreach
            return chosenDirection;
        }

        /// <summary>
        /// returns a list of tiles that surround this tile
        /// why??? needed
        /// </summary>
        /// <param name="pos"></param>
        /// <returns>an array of tile positions</returns>
        private List<Point> SurroundingGraphic(Point pos)
        {
            List<Point> validList = new List<Point>();
            //  lx
            //if (!TileItemHere(TileLeft(pos), illegal))
            //    validList.Add(0);
            ////  xr
            //if (!TileItemHere(TileRight(pos), illegal))
            //    validList.Add(1);
            ////  t
            ////  x
            //if (!TileItemHere(TileUp(pos), illegal))
            //    validList.Add(2);
            ////  x
            ////  b
            //if (!TileItemHere(TileDown(pos), illegal))
            //    validList.Add(3);

            return validList;
        }

        /// <summary>
        /// checks to see if renderproperties are dirty and updates any values necessary
        /// </summary>
        internal void CheckDirty()
        {
            if (RenderProperties.IsDirty)
            {
                //just work with width and height for now
                Width = (int)(ColumnCount * tileWidth * RenderProperties._scaleFactor);
                Height = (int)(RowCount * tileHeight * RenderProperties._scaleFactor);

                RenderProperties.Cleaned();

            }
        }

        /// <summary>
        /// generates a temporary tile sized sprite for testing and special effects,
        /// using a standard plain tile
        /// </summary>
        /// <param name="location">the tile location to render at</param>
        /// <param name="colour">colour wash to apply</param>
        /// <param name="duration">time before the highlight should be remove</param>
        /// <param name="alpha">Transparency to apply</param>
        /// <returns>The highlight sprite create in case you want mess about with it</returns>
        public Sprite Highlight(Point location, Color colour, float duration, float alpha)
        {
            return Highlight(
                location,
                colour,
                duration,
                RenderLayer.hud,
                alpha,
                Tex.SingleWhitePixel,
                //engineManager.SingleWhitePixel,
                0
                );
        }

        /// <summary>
        /// generates a temporary tile sized sprite for testing and special effects
        /// </summary>
        /// <param name="location">the tile location to render at</param>
        /// <param name="colour">colour wash to apply</param>
        /// <param name="duration">time before the highlight should be remove</param>
        /// <param name="layer">The sprite layer to drop this on</param>
        /// <param name="alpha">Transparency to apply</param>
        /// <param name="tex">texture to use</param>
        /// <param name="depth">Z position of sprite within it's layer</param>
        /// <returns>The highlight sprite create in case you want mess about with it</returns>
        public Sprite Highlight(Point location, Color colour, float duration, int layer, float alpha, Image /*Texture2D*/ tex, float depth)
        {
            Sprite s = engineManager.AddSprite();
            if (tex == null)
                s.Frame.Define(Tex.SingleWhitePixel);
            //s.Frame.Define(engineManager.SingleWhitePixel);
            else
                s.Frame.Define(tex);
            s.Wash = colour;
            //takes scaling into account
            SpriteHelper.ScaleToThisSize(s, TileWidth * RenderProperties._scaleFactor, TileHeight * RenderProperties._scaleFactor);
            s.Align = Engine7.Align.topLeft;
            s.Position2D = PixelLocationTopLeft(location) * RenderProperties._scaleFactor; 
            //s.Position2D = TilePosition(tileLocation) ;
            s.Z = depth;

            s.TimerInitialise();
            s.Timer.KillAfter(duration);

            s.Layer = layer;
            s.Alpha = alpha;

            return s;
        }

        /// <summary>
        /// Highlights a particular tilemap location
        /// </summary>
        /// <param name="location">the tile location to render at</param>
        /// <param name="cloneFrom">A set of Sprite data to take settings, see Sprite.GetClone() for a list of all attributes cloned:</param>
        /// <param name="scale">if true the sprite will be scaled to same dimension as tile</param>
        /// <param name="useFrames">If true the frame data will be cloned from the cloneFrom sprite</param>
        /// <returns></returns>
        public Sprite Highlight(Point location, Sprite cloneFrom, bool scale, bool useFrames)
        {
            Sprite s = engineManager.AddSprite();
            s = cloneFrom.GetClone(useFrames);
            if (scale) SpriteHelper.ScaleToThisSize(s, TileWidth, TileHeight);
            return s;
        }
        /// <summary>
        /// Highlights automatically tiles in the directions given from the current tile location
        /// </summary>
        /// <param name="location">central location</param>
        /// <param name="directions">list of tile directions</param>
        /// <param name="colour">colour array to draw directions, which must contain 4 colours, 1 for each direction</param>
        /// <param name="duration">how long for the directions to appear</param>
        /// <param name="alpha">transparency of highlight</param>
        /// <param name="layer">The sprite layer to show the higlighting</param>
        /// <param name="depth">the Z value to assign the highlight</param>
        public void HighlightDirections(Point location, List<int> directions, Color[] colour, float duration, float alpha, int layer, float depth)
        {
            if (colour.Length < 1)
            {
                throw new ArgumentOutOfRangeException("must supply at least 1 colour");
            }
            else
            {
                int colorpick = 0;
                foreach (int direction in directions)
                {
                    
                    //using location so oridnals passed on
                    Highlight(Location(location, direction, 1), colour[colorpick % colour.Length], duration, layer, alpha, null, depth);
                    colorpick++;
                    //switch (direction)
                    //{

                    //    case LEFT:
                    //        Highlight(Location(location, LEFT, 1), colour[0], duration, layer, alpha, null, depth);
                    //        break;
                    //    case RIGHT:
                    //        Highlight(Location(location, RIGHT, 1), colour[1], duration, layer, alpha, null, depth);
                    //        break;
                    //    case UP:
                    //        Highlight(Location(location, UP, 1), colour[2], duration, layer, alpha, null, depth);
                    //        break;
                    //    case DOWN:
                    //        Highlight(Location(location, DOWN, 1), colour[3], duration, layer, alpha, null, depth);
                    //        break;
                    //}
                }
            }
        }

        /// <summary>
        /// Highlights automatically tiles in the directions given from the current tile location
        /// </summary>
        /// <param name="location">central location</param>
        /// <param name="directions">list of tile directions</param>
        /// <param name="colour">colour to draw each highlight</param>
        /// <param name="duration">how long for the directions to appear</param>
        /// <param name="alpha">transparency of highlight</param>
        public void HighlightDirections(Point location, List<int> directions, Color colour, float duration, float alpha)
        {
            HighlightDirections(location, directions, new Color[] { colour, colour, colour, colour }, duration, alpha, RenderLayer.hud, -1000);
        }
    }
}